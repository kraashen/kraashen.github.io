<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Reverse Engineering With Radare - Binary internals | tracing bytes</title>
<meta name=keywords content="reverse engineering,radare,studying"><meta name=description content="In the previous post, basics and fundamentals for reverse engineering software were discussed. This time I thought about writing a bit more about getting a bit further in inspecting and understanding software binaries. In this post, we&rsquo;ll take a look at one password guess reverse engineering challenge using Radare.
Goals The goal is to reverse engineer a simple binary and understanding of the flow of disassembled code, how to read it, and understand how it works."><meta name=author content><link rel=canonical href=https://kraashen.github.io/posts/2018-03-11-reverse-engineering-basics-with-radare-binary-internals/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://kraashen.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://kraashen.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://kraashen.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://kraashen.github.io/apple-touch-icon.png><link rel=mask-icon href=https://kraashen.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://kraashen.github.io/posts/2018-03-11-reverse-engineering-basics-with-radare-binary-internals/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Reverse Engineering With Radare - Binary internals"><meta property="og:description" content="In the previous post, basics and fundamentals for reverse engineering software were discussed. This time I thought about writing a bit more about getting a bit further in inspecting and understanding software binaries. In this post, we&rsquo;ll take a look at one password guess reverse engineering challenge using Radare.
Goals The goal is to reverse engineer a simple binary and understanding of the flow of disassembled code, how to read it, and understand how it works."><meta property="og:type" content="article"><meta property="og:url" content="https://kraashen.github.io/posts/2018-03-11-reverse-engineering-basics-with-radare-binary-internals/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-03-11T00:00:00+00:00"><meta property="article:modified_time" content="2018-03-11T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Reverse Engineering With Radare - Binary internals"><meta name=twitter:description content="In the previous post, basics and fundamentals for reverse engineering software were discussed. This time I thought about writing a bit more about getting a bit further in inspecting and understanding software binaries. In this post, we&rsquo;ll take a look at one password guess reverse engineering challenge using Radare.
Goals The goal is to reverse engineer a simple binary and understanding of the flow of disassembled code, how to read it, and understand how it works."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://kraashen.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Reverse Engineering With Radare - Binary internals","item":"https://kraashen.github.io/posts/2018-03-11-reverse-engineering-basics-with-radare-binary-internals/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Reverse Engineering With Radare - Binary internals","name":"Reverse Engineering With Radare - Binary internals","description":"In the previous post, basics and fundamentals for reverse engineering software were discussed. This time I thought about writing a bit more about getting a bit further in inspecting and understanding software binaries. In this post, we\u0026rsquo;ll take a look at one password guess reverse engineering challenge using Radare.\nGoals The goal is to reverse engineer a simple binary and understanding of the flow of disassembled code, how to read it, and understand how it works.","keywords":["reverse engineering","radare","studying"],"articleBody":"In the previous post, basics and fundamentals for reverse engineering software were discussed. This time I thought about writing a bit more about getting a bit further in inspecting and understanding software binaries. In this post, we’ll take a look at one password guess reverse engineering challenge using Radare.\nGoals The goal is to reverse engineer a simple binary and understanding of the flow of disassembled code, how to read it, and understand how it works. We’ll take a look at concepts such as:\nThe execution of a program: What happens when software is run? A brief look at what are symbols, sections, and segments Checking flags and strings in Radare Understanding program flow and disassembled code Visual graphs Extra: What are stack canaries on Linux? Setup The C code of this exercise is available on Gist. You can go and compile it yourself or you can download the provided binary first which I have included to this post. This exercise is actually based on one Lab exercise I found from Github. I decided to do a similar exercise based on it and rewriting the original just a bit to avoid sploiling the original Lab exercise if, for instance, you’d like to do it later yourself. So after reading, you can also check them out as well. :-) But for now, I’ll focus on keeping the binary as black box’ish.\nDownload the binary\nInformation - ra2bin and iI output As usual, let’s check out some generic information about the binary we will be inspecting. Alternatively, you can run rabin2 -I [path_to_binary] on the command line to get similar information. Rabin2 is a binary information extractor based on Radare. Within Radare, you can use iI command to get this information.\n[0x00000000]\u003e iI arch x86 binsz 7946 bintype elf bits 64 canary true class ELF64 crypto false endian little havecode true intrp /lib64/ld-linux-x86-64.so.2 lang c linenum true lsyms true machine AMD x86-64 architecture maxopsz 16 minopsz 1 nx true os linux pcalign 0 pic true relocs true relro partial rpath NONE static false stripped false subsys linux va true This time though, I’m going to attempt to explain further what the output of this command tells us about binaries. I’ll try my best list them down based on sources I found.\nTerm Explanation arch Architecture for which the binary has been assembled for. binsz Size of the binary program in bits. bintype Type of the binary, e.g. an elf binary is an executable Linux binary. See Executable and Linkable Format Wiki page for more details on linux binaries. Respectively on Windows, this could be Portable Executable (PE) and on OS X a Mach-O binary. bits Bitness of the binary. Commonly 32/64 bit nowadays. canary Does the binary have stack canary protection enabled. class Class of the binary crypto Boolean flag to tell if the binary is encrypted. This is a method in the binary protection. This article from Phrack is a great source to understand binary encryption and its background in more detail. endian Endianness of the binary. See this Wiki page for more details, this is useful to understand later on when endianness can be reversed on some binaries. havecode Probably tells if the binary has debug symbols. I compiled the example binary with debug symbols enabled and disabled and this flag changed depending if debug symbols were enabled or not. intrp Some sources say this as INTERP, file name of the dynamic linker - the interpreter of the program. lang Language which the binary was developed in. linenum This indicates the availability of a line number section that allows mapping from source line numbers to machine code addresses. lsyms This indicates the availability of symbols list of a binary. machine Machine and architecture the binary was compiled on. maxopsz Maximum bit size of an operation the binary includes. (?) minopsz Minimum bit size of an operation the binary includes. (?) nx NX bit is related to executable space protection. This tells us if parts of the memory locations of the binary are marked as non-executable. Processor will then refuse to execute instructions in these memory locations. os Operating system kernel for which the binary has been compiled for. pcalign This is related to data structure alignment. pic Is the binary position-independent code. This means that the machine-code can be placed anywhere in the memory and it would execute regardless of its absolute address. This is common e.g. for shared libraries. relocs Possibly related to concept of relocatable binary. Quite new concept for me. This is related to linking and loading, but how I understood this is that if the binary contains relocation section directives. A dynamically linked binary refers to functions that are located in shared library binaries for instance. Definitely needs further studying before I make too concrete much assumptions :P relro Now continuing the previous topic, this might be related to relocation read-only property of a binary file. This way linker resolves dynamically linked functions at the beginning of execution. rpath Rpath can be a hard-coded value in binary headers that tell the path to find the required linked libraries, overriding or supplementing the system default paths. static A binary can be static or a dynamically linked binary. This tells us which one the binary is. stripped When a binary is stripped, it has the symbols table removed and results in a more compact binary. A non-stripped binary includes more information due to the included symbols table and possible also debug symbols as well. subsys Subsystem to be invoked for this executable. va Might be virtual address as a boolean? This could then mean that the binary includes or supports virtual addressing. This was a section that single-handedly took most of the time of this post - studying binary headers. I feel like I have not even barely scratched the surface of things to come. I don’t understand in depth how linkers and compilers work to safely assume all of these are correct. So, if there is any feedback related to these, I’d gladly fix my understanding of these.\nI also put this one available to Gist as a cheat sheet: https://gist.github.com/anerani/38fbb33edff32027ebabdda83a089769\nSymbols, sections, and segments When you write software and compile it to a binary, the compiler assigns labels to parts of the code you have written. For instance, your functions are labeled: main is a label assigned to the binary representation of the code. These labels are called symbols. When these functions are called or being referenced to, they need to be looked up by the linker either by static linking (compile-time linking) or dynamic linking (while running the software). Symbols are needed for the linker to know where the code can be found.\nWith iS command you can print the sections of the binary. Try it out! There are a handful of sections in the binary but let’s list down some of the useful ones to understand to begin with:\n.interp: The name of the linker. .text: Code of the software is in this segment. .rodata: Read-only data (e.g. initialized hard-coded variables) .data: Initialized data, including variables that have pre-defined values and that can be modified. .bss: Uninitialized data, including global and static variables that are initialized to zero or don’t have explicit initialization. The key difference between a section and a segment is, that a section is used at link-time of the program and a section is used at run-time.\nWhen software starts… Lets see where the entry point of the application is and seek to it. Entrypoints can be listed with command ie. (i= get info from opened file -\u003e entrypoint)\n\u003e aaa [x] Analyze all flags starting with sym. and entry0 (aa) [x] Analyze len bytes of instructions for references (aar) [x] Analyze function calls (aac) [x] Use -AA or aaaa to perform additional experimental analysis. [x] Constructing a function name for fcn.* and sym.func.* functions (aan) \u003e ie [Entrypoints] vaddr=0x00400550 paddr=0x00000550 baddr=0x00400000 laddr=0x00000000 haddr=0x00000018 type=program 1 entrypoints So our entrypoint is at address vaddr=0x00400550, lets seek to it as the main function should be disassembled as well. Lets check it out\n\u003e s 0x400550 (leading zeros can be excluded when defining addresses in hexadecimals, as it does not change the address really) \u003e pdf ;-- section..text: ;-- rip: / (fcn) entry0 41 | entry0 (); | 0x00400550 31ed xor ebp, ebp | 0x00400552 4989d1 mov r9, rdx | 0x00400555 5e pop rsi | 0x00400556 4889e2 mov rdx, rsp | 0x00400559 4883e4f0 and rsp, 0xfffffffffffffff0 | 0x0040055d 50 push rax | 0x0040055e 54 push rsp | 0x0040055f 49c7c0600740. mov r8, sym.__libc_csu_fini ; 0x400760 | 0x00400566 48c7c1f00640. mov rcx, sym.__libc_csu_init ; 0x4006f0 ; \"AWAVA\\x89\\xffAUATL\\x8d%\\x0e\\x07 \" | 0x0040056d 48c7c7510640. mov rdi, sym.main ; 0x400651 \\ 0x00400574 e897ffffff call sym.imp.__libc_start_main ; int __libc_start_main(func main, int argc, char **ubp_av, func init, func fini, func rtld_fini, void *stack_end) Okay, so here we seem to have some brand new information. Lets go through this and see what is happening within an application entrypoint.\n| 0x00400550 31ed xor ebp, ebp The base pointer register is zeroed at the initialization. This is the point where the outermost frame of the application is marked. Performing a XOR operation with the same value sets the value to zero. If you don’t know what is happening at this point, it might be better to read some boolean algebra before continuing forward!\n| 0x00400552 4989d1 mov r9, rdx | 0x00400555 5e pop rsi | 0x00400556 4889e2 mov rdx, rsp | 0x00400559 4883e4f0 and rsp, 0xfffffffffffffff0 | 0x0040055d 50 push rax | 0x0040055e 54 push rsp | 0x0040055f 49c7c0600740. mov r8, sym.__libc_csu_fini ; 0x400760 | 0x00400566 48c7c1f00640. mov rcx, sym.__libc_csu_init ; 0x4006f0 ; \"AWAVA\\x89\\xffAUATL\\x8d%\\x0e\\x07 \" This section will be strongly focused on Linux-spesific startup of a software. This website by Patrick Horgan is a great source to study more about the beginning of software execution.\nIn this phase, data is first initialized to registers. Then, the value from the top of the stack, which is argc (argument count), is popped to rsi register. Binaries also have argument values. As the argument count was popped from the top of the stack, the stack pointer is pointing to argv (argument vector). The address of these is moved to rdx data register and rsp is not moved. Remember how stack works? If you need to fresh your memory, check the previous post!\nNext, the stack pointer is masked with a long mask, clearing the lowest 4 bits. This is done to align the stack pointer for memory and cache efficiency, and certain operations.\nThen, couple of pushes. The values from the rax is pushed to the stack along with the stack pointer rsp to store the return address after the main function is executed.\n__libc_csu_fini is the destructor of the application. __libc_csu_init is the constructor of our application. These are C-level constructor and destructor, to be exact. These are methods that are executed both before and after the our application finishes after the __libc_start_main which will come next.\n| 0x0040056d 48c7c7510640. mov rdi, sym.main ; 0x400651 \\ 0x00400574 e897ffffff call sym.imp.__libc_start_main ; int __libc_start_main(func main, int argc, char **ubp_av, func init, func fini, func rtld_fini, void *stack_end) Here, the address of the main function is moved to rdi. Based on this, the __libc_start_main will load the arguments for it - destructor, constructor, aligned stack pointer, and main function - from the registers. Like it was explained before, it depends e.g. on the architecture if function arguments are passed using the stack or the registers.\nFinally, the __libc_start_main is called and our main function will be executed. This low-level C function handles things such as:\nRegistering constructor and destructor for the application Calls the main() with the corresponding arguments Calls exit when the main function returns What next? Lets check out how we can navigate further in the disassembled codespace.\nNavigating around Flags and info in Radare The previously presented entrypoint is rather common for ELF binaries. Next steps would be to analyze a bit what our binary has eaten. There are various commands where to start from, and here we’ll go through only couple of them.\nih: Print info about file headers is: List symbols of the binary. il: List libraries used by the binary. ii: List imports of the binary. Go ahead: Try them out, and check out i? in your terminal as well!\nNow, after the analysis of the binary, Radare associates names to offsets in the binary. These can be sections, functions, symbols, etc. and are referred to as “flags”.\nYou can list the so called flag space with fs\n\u003e fs 0 4 * strings 1 34 * symbols 2 82 * sections 3 6 * relocs 4 6 * imports In Radare, semi-colon ; can be used to combine multiple commands to same line. Now we can pick a flag space and use plain f to list the flag in that specified flag space:\n\u003e fs imports; f 0x004004f0 16 sym.imp.puts 0x00400500 16 sym.imp.__stack_chk_fail 0x00400510 16 sym.imp.__libc_start_main 0x00400520 16 sym.imp.strcmp 0x00400000 16 loc.imp.__gmon_start 0x00400530 16 sym.imp.__isoc99_scanf Now, one cool command also I learned from Megabeets blog was axt:\n| axt [addr] find data/code references to this address\nRadare also has a @ syntax to refer to a variable, and @@ allows to iterate through the variables given by the second command. These can now be combined to tell us where these imports are being used:\n\u003e \u003e axt @@ sym sym.main 0x40066d [call] call sym.imp.puts sym.main 0x4006d3 [call] call sym.imp.puts sym.main 0x4006b2 [call] call sym.imp.puts sym.main 0x4006da [call] call sym.imp.__stack_chk_fail entry0 0x400574 [call] call sym.imp.__libc_start_main sym.main 0x40069f [call] call sym.imp.strcmp sym.main 0x400683 [call] call sym.imp.__isoc99_scanf Here we can see that the main function is handling pretty much all that have been imported to the application.\nVisual Graphs Radare has a visual mode VV and V, which are user-friendlier ways of exploring the binary data. It uses HJKL keys for navigation in the data and code. If you have used Vim, you’ll be comfortable with the key bindings. You can always exit back to command line using q key. To navigate between different visual views, use p/P keys to go to the next/previous view. In one view, you can also have an ASCII flowchart of the binary logic showing also conditional branching logic between different sections of the code.\nDisassembled main function Time to dive into the main function! Lets seek to it and print its disassembled form.\n\u003e s main ... \u003e pdf ;-- main: / (fcn) sym.main 144 | sym.main (); | ; var int local_24h @ rbp-0x24 | ; var int local_20h @ rbp-0x20 | ; var int local_8h @ rbp-0x8 | ; DATA XREF from 0x0040056d (entry0) | 0x00400651 55 push rbp | 0x00400652 4889e5 mov rbp, rsp | 0x00400655 4883ec30 sub rsp, 0x30 ; '0' | 0x00400659 64488b042528. mov rax, qword fs:[0x28] ; [0x28:8]=-1 ; '(' ; 40 | 0x00400662 488945f8 mov qword [local_8h], rax | 0x00400666 31c0 xor eax, eax | ; JMP XREF from 0x004006d8 (sym.main) | .-\u003e 0x00400668 bf83074000 mov edi, str.Enter_password: ; 0x400783 ; \"Enter password: \" | : 0x0040066d e87efeffff call sym.imp.puts ; int puts(const char *s) | : 0x00400672 488d45e0 lea rax, [local_20h] | : 0x00400676 4889c6 mov rsi, rax | : 0x00400679 bf94074000 mov edi, 0x400794 | : 0x0040067e b800000000 mov eax, 0 | : 0x00400683 e8a8feffff call sym.imp.__isoc99_scanf | : 0x00400688 b800000000 mov eax, 0 | : 0x0040068d e8b4ffffff call sym.get_secret | : 0x00400692 4889c2 mov rdx, rax | : 0x00400695 488d45e0 lea rax, [local_20h] | : 0x00400699 4889d6 mov rsi, rdx | : 0x0040069c 4889c7 mov rdi, rax | : 0x0040069f e87cfeffff call sym.imp.strcmp ; int strcmp(const char *s1, const char *s2) | : 0x004006a4 8945dc mov dword [local_24h], eax | : 0x004006a7 837ddc00 cmp dword [local_24h], 0 | ,==\u003c 0x004006ab 7521 jne 0x4006ce | |: 0x004006ad bf97074000 mov edi, str.Correct ; 0x400797 ; \"Correct!\" | |: 0x004006b2 e839feffff call sym.imp.puts ; int puts(const char *s) | |: 0x004006b7 90 nop | |: 0x004006b8 b800000000 mov eax, 0 | |: 0x004006bd 488b4df8 mov rcx, qword [local_8h] | |: 0x004006c1 6448330c2528. xor rcx, qword fs:[0x28] | ,===\u003c 0x004006ca 7413 je 0x4006df | ,====\u003c 0x004006cc eb0c jmp 0x4006da | |||: ; JMP XREF from 0x004006ab (sym.main) | ||`--\u003e 0x004006ce bfa0074000 mov edi, str.Wrong ; 0x4007a0 ; \"Wrong!\" | || : 0x004006d3 e818feffff call sym.imp.puts ; int puts(const char *s) | || `=\u003c 0x004006d8 eb8e jmp 0x400668 | || ; JMP XREF from 0x004006cc (sym.main) | `----\u003e 0x004006da e821feffff call sym.imp.__stack_chk_fail ; void __stack_chk_fail(void) | | ; JMP XREF from 0x004006ca (sym.main) | `---\u003e 0x004006df c9 leave \\ 0x004006e0 c3 ret Lets break it down to steps:\n;-- main: / (fcn) sym.main 144 | sym.main (); | ; var int local_24h @ rbp-0x24 | ; var int local_20h @ rbp-0x20 | ; var int local_8h @ rbp-0x8 | ; DATA XREF from 0x0040056d (entry0) This comment section in the beginning of the disassembled main function tells us that the function has three local variables that are in the scope of the function, indicated by the local_ prefix. They are located in the offset of rbp-0x[hexvalue]. Also the DATA XREF tell that the function was cross referenced from the given address.\n\u003e pdf @ 0x0040056d which outputs the entrypoint function we analyzed earlier. You can read more about cross references from here. With analyze function variable display command, we could check out the values of the local variables e.g. when debugging the application and setting breakpoints during the process.\n\u003e afvd var local_8h = 0xfffffffffffffff8 0xffffffffffffffff ........ var local_20h = 0xffffffffffffffe0 0xffffffffffffffff ........ var local_24h = 0xffffffffffffffdc 0xffffffffffffffff ........ Alright, onwards.\n| 0x00400651 55 push rbp | 0x00400652 4889e5 mov rbp, rsp | 0x00400655 4883ec30 sub rsp, 0x30 ; '0' | 0x00400659 64488b042528. mov rax, qword fs:[0x28] ; [0x28:8]=-1 ; '(' ; 40 | 0x00400662 488945f8 mov qword [local_8h], rax | 0x00400666 31c0 xor eax, eax Base pointer is pushed to the stack to store the point where to resume the execution from and previous stack pointer value is put into to the base pointer register. Then, stack pointer is moved to reserve space for the upcoming variables (remember, stack “grows” downwards in the address space - hence the reduction). This is common way of function “prologues” in assembly.\nAlso it seems that a value from fs offset 0x28 is moved to rax. qword means that this operand has a size of a quad-word (word is 2 bytes = 8 bytes long). Then, the value at rax is loaded to local variable. What do the brackets mean? Effectively with mov opcodes, brackets mean that “dereference the value at the given address”. Finally, the eax register is zeroed.\n| .-\u003e 0x00400668 bf83074000 mov edi, str.Enter_password: ; 0x400783 ; \"Enter password: \" | : 0x0040066d e87efeffff call sym.imp.puts ; int puts(const char *s) | : 0x00400672 488d45e0 lea rax, [local_20h] | : 0x00400676 4889c6 mov rsi, rax | : 0x00400679 bf94074000 mov edi, 0x400794 | : 0x0040067e b800000000 mov eax, 0 | : 0x00400683 e8a8feffff call sym.imp.__isoc99_scanf | : 0x00400688 b800000000 mov eax, 0 | : 0x0040068d e8b4ffffff call sym.get_secret The string “Enter password: \" is moved to edi and an imported function puts is called, which outputs the string to the stdout. Then, the computed address of a local variable is set in rax. lea, load effective address works pretty much similarly as mov but instead of loading or moving the value, the calculated effective address is moved to the target register instead, which can be dereferenced later.\nAt the end, scanf is called for user input. After that, get_secret is called, which seems to be interesting based on its name.\n| : 0x00400692 4889c2 mov rdx, rax | : 0x00400695 488d45e0 lea rax, [local_20h] | : 0x00400699 4889d6 mov rsi, rdx | : 0x0040069c 4889c7 mov rdi, rax | : 0x0040069f e87cfeffff call sym.imp.strcmp ; int strcmp(const char *s1, const char *s2) | : 0x004006a4 8945dc mov dword [local_24h], eax | : 0x004006a7 837ddc00 cmp dword [local_24h], 0 | ,==\u003c 0x004006ab 7521 jne 0x4006ce Based on the four following instructions before strcmp call, seems like the value of the function get_secret is stored in rax and is moved to rdx. The value of the user input on the other hand is stored in the local variable and its effective address is loaded to rax. Then, the values to be compared are loaded to rsi and rdi respectively and strcmp is called to compare them. Result of this function call is stored in eax and then it is compared. Values of these comparisons are stored in flag registers that were discussed in the previous post. If the comparison failed, jne jumps to the specified memory address and following sequence is executed:\n| ||`--\u003e 0x004006ce bfa0074000 mov edi, str.Wrong ; 0x4007a0 ; \"Wrong!\" | || : 0x004006d3 e818feffff call sym.imp.puts ; int puts(const char *s) | || `=\u003c 0x004006d8 eb8e jmp 0x400668 So a string “Wrong!” is printed to stdout and execution flow jumps to the given address, which is in the beginning of the main function.\n| |: 0x004006ad bf97074000 mov edi, str.Correct ; 0x400797 ; \"Correct!\" | |: 0x004006b2 e839feffff call sym.imp.puts ; int puts(const char *s) | |: 0x004006b7 90 nop | |: 0x004006b8 b800000000 mov eax, 0 | |: 0x004006bd 488b4df8 mov rcx, qword [local_8h] | |: 0x004006c1 6448330c2528. xor rcx, qword fs:[0x28] | ,===\u003c 0x004006ca 7413 je 0x4006df | ,====\u003c 0x004006cc eb0c jmp 0x4006da | |||: ; JMP XREF from 0x004006ab (sym.main) | ||`--\u003e 0x004006ce bfa0074000 mov edi, str.Wrong ; 0x4007a0 ; \"Wrong!\" | || : 0x004006d3 e818feffff call sym.imp.puts ; int puts(const char *s) | || `=\u003c 0x004006d8 eb8e jmp 0x400668 | || ; JMP XREF from 0x004006cc (sym.main) | `----\u003e 0x004006da e821feffff call sym.imp.__stack_chk_fail ; void __stack_chk_fail(void) | | ; JMP XREF from 0x004006ca (sym.main) | `---\u003e 0x004006df c9 leave \\ 0x004006e0 c3 ret Rest of the code should be now quite understandable based on some of the basic principles we learned on our way here. The left side arrows indicate the flow within the main function and je and jmp opcodes are defining the execution flow. When the user gives the correct string, the function leaves the loop and returns, effectively ending our main loop.\nFinding the secret Now we have seen the main function and know how to navigate around a bit. There are multiple ways of doing this of course, but for practice lets check out what the get_secret() function does as it sounds interesting.\n\u003e s sym.get_secret [0x00400646]\u003e pdf / (fcn) sym.get_secret 11 | sym.get_secret (); | ; CALL XREF from 0x0040068d (sym.main) | 0x00400646 55 push rbp | 0x00400647 4889e5 mov rbp, rsp | 0x0040064a b874074000 mov eax, str.s3cr37p455w0rd ; 0x400774 ; \"s3cr37p455w0rd\" | 0x0040064f 5d pop rbp \\ 0x00400650 c3 ret Seems like this function is quite simple: Base pointer is pushed to the stack to store the return address where the execution of the program will continue, stack pointer is moved to point to the current frame and a quite distinguishing string variable is moved to the eax register. Finally the base pointer is popped back from the stack and function returns, resuming the execution of our application.\nLets try this password out:\n$ ./a.out Enter password: s3cr37p455w0rd Correct! Alternative ways: File info revisited I intentionally skipped one useful info command: iz. This prints information about the strings located in the binary itself. This though reveals also the answer to our top-secret exercise. Whoops! Why? Well, it’s stored hard-coded as a variable within the binary itself.\n\u003e iz 000 0x00000774 0x00400774 14 15 (.rodata) ascii s3cr37p455w0rd 001 0x00000783 0x00400783 16 17 (.rodata) ascii Enter password: 002 0x00000797 0x00400797 8 9 (.rodata) ascii Correct! 003 0x000007a0 0x004007a0 6 7 (.rodata) ascii Wrong! Still, this can be a very useful command to remember as well when debugging or reversing software. Also if you explored the flag more earlier, you might have done:\n\u003e fs strings; f 0x00400774 15 str.s3cr37p455w0rd 0x00400783 17 str.Enter_password: 0x00400797 9 str.Correct 0x004007a0 7 str.Wrong Extra: Stack canaries? In the original lab exercise, one thing caught my eye: it was compiled with stack protection enabled, which is used by e.g. as a gcc flag -fstack-protect-all. This resulted in an interesting program initialization assembly:\n| `----\u003e 0x004006da e821feffff call sym.imp.__stack_chk_fail ; void __stack_chk_fail(void) What are stack canaries? This blog post was an excellent wrap-up of the topic. In short, a stack canary is a feature in binaries to protect from malicious buffer overflows on variables that have been allocated in stack.\nConclusions Well, there it is! Understanding of basics of computer architectures, memory handling in assembly were visited, and how to navigate and use basic functionalities of Radare. Time to dive into reverse engineering on real-world software binaries or write some own to practice with!\nOne options would be to look with a search engine for capture-the-flag exercises and challenges, as well as excellent Radare tutorials out there. CTF challenges are good way to start prepping puzzle skills hand-in-hand with binary analysis and can really twist your brains.\nReferences Github Project - Practical Reverse Engineering using Radare2 Phrack: Armouring the ELF: Binary encryption on the UNIX platform Executable and Linking Format (ELF) Wikipedia: Data structure alignment Wikipedia: Position-independent code Wikipedia: Relocatable binary Wikipedia: Rpath Wikipedia: Endianness Wikipedia: Executable and Linkable Format Patric Horgan: Linux x86 Program Start Up or - How the heck do we get to main()? Megabeets: A Journey Into Radare2 Part 1 xorl %eax, %eax: Linux Glibc - Stack Canary Values ","wordCount":"4252","inLanguage":"en","datePublished":"2018-03-11T00:00:00Z","dateModified":"2018-03-11T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://kraashen.github.io/posts/2018-03-11-reverse-engineering-basics-with-radare-binary-internals/"},"publisher":{"@type":"Organization","name":"tracing bytes","logo":{"@type":"ImageObject","url":"https://kraashen.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://kraashen.github.io/ accesskey=h title="tracing bytes (Alt + H)">tracing bytes</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://kraashen.github.io/ title=Home><span>Home</span></a></li><li><a href=https://kraashen.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://kraashen.github.io/snippets/ title=Snippets><span>Snippets</span></a></li><li><a href=https://kraashen.github.io/my-library/ title="My Library"><span>My Library</span></a></li><li><a href=https://kraashen.github.io/interests/ title=Interests><span>Interests</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Reverse Engineering With Radare - Binary internals</h1><div class=post-meta><span title='2018-03-11 00:00:00 +0000 UTC'>March 11, 2018</span></div></header><div class=post-content><p>In the <a href=/posts/2018-01-22-reverse-engineering-basics-with-radare-fundamentals-and-basics/>previous post</a>, basics and fundamentals for reverse engineering software were discussed. This time I thought about writing a bit more about getting a bit further in inspecting and understanding software binaries. In this post, we&rsquo;ll take a look at one password guess reverse engineering challenge using Radare.</p><h2 id=goals>Goals<a hidden class=anchor aria-hidden=true href=#goals>#</a></h2><p>The goal is to reverse engineer a simple binary and understanding of the flow of disassembled code, how to read it, and understand how it works. We&rsquo;ll take a look at concepts such as:</p><ul><li>The execution of a program: What happens when software is run?</li><li>A brief look at what are symbols, sections, and segments</li><li>Checking flags and strings in Radare</li><li>Understanding program flow and disassembled code</li><li>Visual graphs</li><li>Extra: What are stack canaries on Linux?</li></ul><h2 id=setup>Setup<a hidden class=anchor aria-hidden=true href=#setup>#</a></h2><p>The C code of this exercise is <a href=https://gist.github.com/anerani/4dc0d684d2f22939eb63bc76cf591e49>available on Gist</a>. You can go and compile it yourself
or you can download the provided binary first which I have included to this post. This exercise is actually based on one <a href=https://github.com/s4n7h0/Practical-Reverse-Engineering-using-Radare2/>Lab exercise I found from Github</a>.
I decided to do a similar exercise based on it and rewriting the original just a bit to avoid sploiling the
original Lab exercise if, for instance, you&rsquo;d like to do it later yourself. So after reading, you can also check them out as well. :-) But for now, I&rsquo;ll focus on keeping the binary as black box&rsquo;ish.</p><p><a href=/examples/exercise.bin>Download the binary</a></p><h2 id=information---ra2bin-and-ii-output>Information - ra2bin and iI output<a hidden class=anchor aria-hidden=true href=#information---ra2bin-and-ii-output>#</a></h2><p>As usual, let&rsquo;s check out some generic information about the binary we will be inspecting. Alternatively, you can run <code>rabin2 -I [path_to_binary]</code> on the command line to get similar information. <strong>Rabin2</strong> is a binary information extractor based on Radare. Within Radare, you can use <code>iI</code> command to get this information.</p><pre tabindex=0><code>[0x00000000]&gt; iI
arch     x86
binsz    7946
bintype  elf
bits     64
canary   true
class    ELF64
crypto   false
endian   little
havecode true
intrp    /lib64/ld-linux-x86-64.so.2
lang     c
linenum  true
lsyms    true
machine  AMD x86-64 architecture
maxopsz  16
minopsz  1
nx       true
os       linux
pcalign  0
pic      true
relocs   true
relro    partial
rpath    NONE
static   false
stripped false
subsys   linux
va       true
</code></pre><p>This time though, I&rsquo;m going to attempt to explain further what the output of this command tells us about binaries. I&rsquo;ll try my best list them down based on sources I found.</p><table><thead><tr><th style=text-align:center>Term</th><th>Explanation</th></tr></thead><tbody><tr><td style=text-align:center><strong>arch</strong></td><td>Architecture for which the binary has been assembled for.</td></tr><tr><td style=text-align:center><strong>binsz</strong></td><td>Size of the binary program in bits.</td></tr><tr><td style=text-align:center><strong>bintype</strong></td><td>Type of the binary, e.g. an <code>elf</code> binary is an executable Linux binary. See <a href=https://en.wikipedia.org/wiki/Executable_and_Linkable_Format>Executable and Linkable Format Wiki page</a> for more details on linux binaries. Respectively on Windows, this could be Portable Executable (PE) and on OS X a Mach-O binary.</td></tr><tr><td style=text-align:center><strong>bits</strong></td><td>Bitness of the binary. Commonly 32/64 bit nowadays.</td></tr><tr><td style=text-align:center><strong>canary</strong></td><td>Does the binary have stack canary protection enabled.</td></tr><tr><td style=text-align:center><strong>class</strong></td><td>Class of the binary</td></tr><tr><td style=text-align:center><strong>crypto</strong></td><td>Boolean flag to tell if the binary is encrypted. This is a method in the binary protection. <a href=https://grugq.github.io/docs/phrack-58-05.txt>This article from Phrack</a> is a great source to understand binary encryption and its background in more detail.</td></tr><tr><td style=text-align:center><strong>endian</strong></td><td>Endianness of the binary. See <a href=https://en.wikipedia.org/wiki/Endianness>this Wiki page</a> for more details, this is useful to understand later on when endianness can be reversed on some binaries.</td></tr><tr><td style=text-align:center><strong>havecode</strong></td><td>Probably tells if the binary has debug symbols. I compiled the example binary with debug symbols enabled and disabled and this flag changed depending if debug symbols were enabled or not.</td></tr><tr><td style=text-align:center><strong>intrp</strong></td><td>Some sources say this as <code>INTERP</code>, file name of the dynamic linker - the interpreter of the program.</td></tr><tr><td style=text-align:center><strong>lang</strong></td><td>Language which the binary was developed in.</td></tr><tr><td style=text-align:center><strong>linenum</strong></td><td>This indicates the availability of a <a href=http://www.vxdev.com/docs/vx55man/diab5.0ppc/x-elf_fo.htm#3001084>line number section</a> that allows mapping from source line numbers to machine code addresses.</td></tr><tr><td style=text-align:center><strong>lsyms</strong></td><td>This indicates the availability of symbols list of a binary.</td></tr><tr><td style=text-align:center><strong>machine</strong></td><td>Machine and architecture the binary was compiled on.</td></tr><tr><td style=text-align:center><strong>maxopsz</strong></td><td>Maximum bit size of an operation the binary includes. (?)</td></tr><tr><td style=text-align:center><strong>minopsz</strong></td><td>Minimum bit size of an operation the binary includes. (?)</td></tr><tr><td style=text-align:center><strong>nx</strong></td><td>NX bit is related to executable space protection. This tells us if parts of the memory locations of the binary are marked as non-executable. Processor will then refuse to execute instructions in these memory locations.</td></tr><tr><td style=text-align:center><strong>os</strong></td><td>Operating system kernel for which the binary has been compiled for.</td></tr><tr><td style=text-align:center><strong>pcalign</strong></td><td>This is related to <a href=https://en.wikipedia.org/wiki/Data_structure_alignment>data structure alignment</a>.</td></tr><tr><td style=text-align:center><strong>pic</strong></td><td>Is the binary <a href=https://en.wikipedia.org/wiki/Position-independent_code>position-independent code</a>. This means that the machine-code can be placed anywhere in the memory and it would execute regardless of its absolute address. This is common e.g. for shared libraries.</td></tr><tr><td style=text-align:center><strong>relocs</strong></td><td>Possibly related to concept of <a href=https://en.wikipedia.org/wiki/Relocation_(computing)>relocatable binary</a>. Quite new concept for me. This is related to linking and loading, but how I understood this is that if the binary contains relocation section directives. A dynamically linked binary refers to functions that are located in shared library binaries for instance. Definitely needs further studying before I make too concrete much assumptions :P</td></tr><tr><td style=text-align:center><strong>relro</strong></td><td>Now continuing the previous topic, this might be related to relocation read-only property of a binary file. This way linker resolves dynamically linked functions at the beginning of execution.</td></tr><tr><td style=text-align:center><strong>rpath</strong></td><td><a href=https://en.wikipedia.org/wiki/Rpath>Rpath</a> can be a hard-coded value in binary headers that tell the path to find the required linked libraries, overriding or supplementing the system default paths.</td></tr><tr><td style=text-align:center><strong>static</strong></td><td>A binary can be static or a dynamically linked binary. This tells us which one the binary is.</td></tr><tr><td style=text-align:center><strong>stripped</strong></td><td>When a binary is stripped, it has the symbols table removed and results in a more compact binary. A non-stripped binary includes more information due to the included symbols table and possible also debug symbols as well.</td></tr><tr><td style=text-align:center><strong>subsys</strong></td><td>Subsystem to be invoked for this executable.</td></tr><tr><td style=text-align:center><strong>va</strong></td><td>Might be virtual address as a boolean? This could then mean that the binary includes or supports virtual addressing.</td></tr></tbody></table><p>This was a section that single-handedly took most of the time of this post - studying binary headers. I feel like I have not even barely scratched the surface of things to come. I don&rsquo;t understand in depth how linkers and compilers work to safely assume all of these are correct. So, if there is any feedback related to these, I&rsquo;d gladly fix my understanding of these.</p><p>I also put this one available to Gist as a cheat sheet: <a href=https://gist.github.com/anerani/38fbb33edff32027ebabdda83a089769>https://gist.github.com/anerani/38fbb33edff32027ebabdda83a089769</a></p><h2 id=symbols-sections-and-segments>Symbols, sections, and segments<a hidden class=anchor aria-hidden=true href=#symbols-sections-and-segments>#</a></h2><p>When you write software and compile it to a binary, the compiler assigns labels to parts of the code you have written. For instance, your functions are labeled: <code>main</code> is a label assigned to the binary representation of the code. These labels are called <em>symbols</em>. When these functions are called or being referenced to, they need to be looked up by the linker either by static linking (compile-time linking) or dynamic linking (while running the software). Symbols are needed for the linker to know where the code can be found.</p><p>With <code>iS</code> command you can print the sections of the binary. Try it out! There are a handful of sections in the binary but let&rsquo;s list down some of the useful ones to understand to begin with:</p><ul><li><strong>.interp</strong>: The name of the linker.</li><li><strong>.text</strong>: Code of the software is in this segment.</li><li><strong>.rodata</strong>: Read-only data (e.g. initialized hard-coded variables)</li><li><strong>.data</strong>: Initialized data, including variables that have pre-defined values and that can be modified.</li><li><strong>.bss</strong>: Uninitialized data, including global and static variables that are initialized to zero or don&rsquo;t have explicit initialization.</li></ul><p>The key difference between a section and a segment is, that a section is used at link-time of the program and a section is used at run-time.</p><h2 id=when-software-starts>When software starts&mldr;<a hidden class=anchor aria-hidden=true href=#when-software-starts>#</a></h2><p>Lets see where the entry point of the application is and seek to it. Entrypoints can be listed with command <code>ie</code>. (<code>i</code>= get info from opened file -> entrypoint)</p><pre tabindex=0><code>&gt; aaa
[x] Analyze all flags starting with sym. and entry0 (aa)
[x] Analyze len bytes of instructions for references (aar)
[x] Analyze function calls (aac)
[x] Use -AA or aaaa to perform additional experimental analysis.
[x] Constructing a function name for fcn.* and sym.func.* functions (aan)

&gt; ie
[Entrypoints]
vaddr=0x00400550 paddr=0x00000550 baddr=0x00400000 laddr=0x00000000 haddr=0x00000018 type=program

1 entrypoints
</code></pre><p>So our entrypoint is at address <code>vaddr=0x00400550</code>, lets seek to it as the main function should be disassembled as well. Lets check it out</p><pre tabindex=0><code>&gt; s 0x400550 (leading zeros can be excluded when defining addresses in hexadecimals, as it does not change the address really)
&gt; pdf
            ;-- section..text:
            ;-- rip:
/ (fcn) entry0 41
|   entry0 ();
|           0x00400550      31ed           xor ebp, ebp                
|           0x00400552      4989d1         mov r9, rdx
|           0x00400555      5e             pop rsi
|           0x00400556      4889e2         mov rdx, rsp
|           0x00400559      4883e4f0       and rsp, 0xfffffffffffffff0
|           0x0040055d      50             push rax
|           0x0040055e      54             push rsp
|           0x0040055f      49c7c0600740.  mov r8, sym.__libc_csu_fini ; 0x400760
|           0x00400566      48c7c1f00640.  mov rcx, sym.__libc_csu_init ; 0x4006f0 ; &#34;AWAVA\x89\xffAUATL\x8d%\x0e\x07 &#34;
|           0x0040056d      48c7c7510640.  mov rdi, sym.main           ; 0x400651
\           0x00400574      e897ffffff     call sym.imp.__libc_start_main ; int __libc_start_main(func main, int argc, char **ubp_av, func init, func fini, func rtld_fini, void *stack_end)
</code></pre><p>Okay, so here we seem to have some brand new information. Lets go through this and see what is happening within an application entrypoint.</p><pre tabindex=0><code>|           0x00400550      31ed           xor ebp, ebp
</code></pre><p>The base pointer register is zeroed at the initialization. This is the point where the outermost frame of the application is marked. Performing a XOR operation with the same value sets the value to zero. If you don&rsquo;t know what is happening at this point, it might be better to read some boolean algebra before continuing forward!</p><pre tabindex=0><code>|           0x00400552      4989d1         mov r9, rdx
|           0x00400555      5e             pop rsi
|           0x00400556      4889e2         mov rdx, rsp
|           0x00400559      4883e4f0       and rsp, 0xfffffffffffffff0
|           0x0040055d      50             push rax
|           0x0040055e      54             push rsp
|           0x0040055f      49c7c0600740.  mov r8, sym.__libc_csu_fini ; 0x400760
|           0x00400566      48c7c1f00640.  mov rcx, sym.__libc_csu_init ; 0x4006f0 ; &#34;AWAVA\x89\xffAUATL\x8d%\x0e\x07 &#34;
</code></pre><p>This section will be strongly focused on Linux-spesific startup of a software. <a href=http://dbp-consulting.com/tutorials/debugging/linuxProgramStartup.html>This website</a> by Patrick Horgan is a great source to study more about the beginning of software execution.</p><p>In this phase, data is first initialized to registers. Then, the value from the top of the stack, which is <code>argc</code> (argument count), is popped to <code>rsi</code> register. Binaries also have argument values. As the argument count was popped from the top of the stack, the stack pointer is pointing to <code>argv</code> (argument vector). The address of these is moved to <code>rdx</code> data register and <code>rsp</code> is not moved. Remember how stack works? If you need to fresh your memory, check the <a href=/posts/2018-01-22-reverse-engineering-basics-with-radare-fundamentals-and-basics/>previous post</a>!</p><p>Next, the stack pointer is masked with a long mask, clearing the lowest 4 bits. This is done to align the stack pointer for memory and cache efficiency, and certain operations.</p><p>Then, couple of pushes. The values from the <code>rax</code> is pushed to the stack along with the stack pointer <code>rsp</code> to store the return address after the main function is executed.</p><p><code>__libc_csu_fini</code> is the destructor of the application. <code>__libc_csu_init</code> is the constructor of our application. These are C-level constructor and destructor, to be exact. These are methods that are executed both before and after the our application finishes after the <code>__libc_start_main</code> which will come next.</p><pre tabindex=0><code>|           0x0040056d      48c7c7510640.  mov rdi, sym.main           ; 0x400651
\           0x00400574      e897ffffff     call sym.imp.__libc_start_main ; int __libc_start_main(func main, int argc, char **ubp_av, func init, func fini, func rtld_fini, void *stack_end)
</code></pre><p>Here, the address of the main function is moved to <code>rdi</code>. Based on this, the <code>__libc_start_main</code> will load the arguments for it - destructor, constructor, aligned stack pointer, and main function - from the registers. Like it was explained before, it depends e.g. on the architecture if function arguments are passed using the stack or the registers.</p><p>Finally, the <code>__libc_start_main</code> is called and our main function will be executed. This low-level C function handles things such as:</p><ul><li>Registering constructor and destructor for the application</li><li>Calls the <code>main()</code> with the corresponding arguments</li><li>Calls exit when the main function returns</li></ul><p>What next? Lets check out how we can navigate further in the disassembled codespace.</p><h2 id=navigating-around>Navigating around<a hidden class=anchor aria-hidden=true href=#navigating-around>#</a></h2><h3 id=flags-and-info-in-radare>Flags and info in Radare<a hidden class=anchor aria-hidden=true href=#flags-and-info-in-radare>#</a></h3><p>The previously presented entrypoint is rather common for ELF binaries. Next steps would be to analyze a bit what our binary has eaten. There are various commands where to start from, and here we&rsquo;ll go through only couple of them.</p><ul><li><code>ih</code>: Print info about file headers</li><li><code>is</code>: List symbols of the binary.</li><li><code>il</code>: List libraries used by the binary.</li><li><code>ii</code>: List imports of the binary.</li></ul><p>Go ahead: Try them out, and check out <code>i?</code> in your terminal as well!</p><p>Now, after the analysis of the binary, Radare associates names to offsets in the binary. These can be sections, functions, symbols, etc. and are referred to as &ldquo;flags&rdquo;.</p><p>You can list the so called flag space with <code>fs</code></p><pre tabindex=0><code>&gt; fs
0    4 * strings
1   34 * symbols
2   82 * sections
3    6 * relocs
4    6 * imports
</code></pre><p>In Radare, semi-colon <code>;</code> can be used to combine multiple commands to same line. Now we can pick a flag space and use plain <code>f</code> to list the flag in that specified flag space:</p><pre tabindex=0><code>&gt; fs imports; f
0x004004f0 16 sym.imp.puts
0x00400500 16 sym.imp.__stack_chk_fail
0x00400510 16 sym.imp.__libc_start_main
0x00400520 16 sym.imp.strcmp
0x00400000 16 loc.imp.__gmon_start
0x00400530 16 sym.imp.__isoc99_scanf
</code></pre><p>Now, one cool command also I learned from <a href=https://www.megabeets.net/a-journey-into-radare-2-part-1/>Megabeets blog</a> was <code>axt</code>:</p><blockquote><p>| axt [addr] find data/code references to this address</p></blockquote><p>Radare also has a <code>@</code> syntax to refer to a variable, and <code>@@</code> allows to iterate through the variables given by the second command. These can now be combined to tell us where these imports are being used:</p><pre tabindex=0><code>&gt; &gt; axt @@ sym
sym.main 0x40066d [call] call sym.imp.puts
sym.main 0x4006d3 [call] call sym.imp.puts
sym.main 0x4006b2 [call] call sym.imp.puts
sym.main 0x4006da [call] call sym.imp.__stack_chk_fail
entry0 0x400574 [call] call sym.imp.__libc_start_main
sym.main 0x40069f [call] call sym.imp.strcmp
sym.main 0x400683 [call] call sym.imp.__isoc99_scanf
</code></pre><p>Here we can see that the main function is handling pretty much all that have been imported to the application.</p><h3 id=visual-graphs>Visual Graphs<a hidden class=anchor aria-hidden=true href=#visual-graphs>#</a></h3><p>Radare has a visual mode <code>VV</code> and <code>V</code>, which are user-friendlier ways of exploring the binary data. It uses <code>HJKL</code> keys for navigation in the data and code. If you have used Vim, you&rsquo;ll be comfortable with the key bindings. You can always exit back to command line using <code>q</code> key. To navigate between different visual views, use <code>p/P</code> keys to go to the next/previous view. In one view, you can also have an ASCII flowchart of the binary logic showing also conditional branching logic between different sections of the code.</p><p><img loading=lazy src=/img/Vflow1.PNG alt>
<img loading=lazy src=/img/Vflow2.PNG alt>
<img loading=lazy src=/img/VVflow1.PNG alt></p><h2 id=disassembled-main-function>Disassembled main function<a hidden class=anchor aria-hidden=true href=#disassembled-main-function>#</a></h2><p>Time to dive into the main function! Lets seek to it and print its disassembled form.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=line><span class=cl><span class=err>&gt;</span> <span class=nf>s</span> <span class=no>main</span>
</span></span><span class=line><span class=cl><span class=na>...</span>
</span></span><span class=line><span class=cl><span class=err>&gt;</span> <span class=nf>pdf</span>
</span></span><span class=line><span class=cl>            <span class=c1>;-- main:
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=err>/</span> <span class=err>(</span><span class=nf>fcn</span><span class=p>)</span> <span class=no>sym.main</span> <span class=mi>144</span>
</span></span><span class=line><span class=cl><span class=err>|</span>   <span class=nf>sym.main</span> <span class=p>()</span><span class=c1>;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=err>|</span>           <span class=c1>; var int local_24h @ rbp-0x24
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=err>|</span>           <span class=c1>; var int local_20h @ rbp-0x20
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=err>|</span>           <span class=c1>; var int local_8h @ rbp-0x8
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=err>|</span>              <span class=c1>; DATA XREF from 0x0040056d (entry0)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=err>|</span>           <span class=err>0</span><span class=nf>x00400651</span>      <span class=mi>55</span>             <span class=no>push</span> <span class=no>rbp</span>
</span></span><span class=line><span class=cl><span class=err>|</span>           <span class=err>0</span><span class=nf>x00400652</span>      <span class=mi>4889</span><span class=no>e5</span>         <span class=no>mov</span> <span class=no>rbp</span><span class=p>,</span> <span class=no>rsp</span>
</span></span><span class=line><span class=cl><span class=err>|</span>           <span class=err>0</span><span class=nf>x00400655</span>      <span class=mi>4883</span><span class=no>ec30</span>       <span class=no>sub</span> <span class=no>rsp</span><span class=p>,</span> <span class=mi>0x30</span>               <span class=c1>; &#39;0&#39;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=err>|</span>           <span class=err>0</span><span class=nf>x00400659</span>      <span class=mi>64488</span><span class=no>b042528.</span>  <span class=no>mov</span> <span class=no>rax</span><span class=p>,</span> <span class=no>qword</span> <span class=no>fs</span><span class=p>:[</span><span class=mi>0x28</span><span class=p>]</span>    <span class=c1>; [0x28:8]=-1 ; &#39;(&#39; ; 40
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=err>|</span>           <span class=err>0</span><span class=nf>x00400662</span>      <span class=mi>488945</span><span class=no>f8</span>       <span class=no>mov</span> <span class=no>qword</span> <span class=p>[</span><span class=no>local_8h</span><span class=p>],</span> <span class=no>rax</span>
</span></span><span class=line><span class=cl><span class=err>|</span>           <span class=err>0</span><span class=nf>x00400666</span>      <span class=mi>31</span><span class=no>c0</span>           <span class=no>xor</span> <span class=no>eax</span><span class=p>,</span> <span class=no>eax</span>
</span></span><span class=line><span class=cl><span class=err>|</span>              <span class=c1>; JMP XREF from 0x004006d8 (sym.main)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=err>|</span>       <span class=nf>.-</span><span class=err>&gt;</span> <span class=mi>0x00400668</span>      <span class=no>bf83074000</span>     <span class=no>mov</span> <span class=no>edi</span><span class=p>,</span> <span class=no>str.Enter_password</span><span class=p>:</span> <span class=c1>; 0x400783 ; &#34;Enter password: &#34;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=err>|</span>       <span class=err>:</span>   <span class=err>0</span><span class=nf>x0040066d</span>      <span class=no>e87efeffff</span>     <span class=no>call</span> <span class=no>sym.imp.puts</span>           <span class=c1>; int puts(const char *s)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=err>|</span>       <span class=err>:</span>   <span class=err>0</span><span class=nf>x00400672</span>      <span class=mi>488</span><span class=no>d45e0</span>       <span class=no>lea</span> <span class=no>rax</span><span class=p>,</span> <span class=p>[</span><span class=no>local_20h</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=err>|</span>       <span class=err>:</span>   <span class=err>0</span><span class=nf>x00400676</span>      <span class=mi>4889</span><span class=no>c6</span>         <span class=no>mov</span> <span class=no>rsi</span><span class=p>,</span> <span class=no>rax</span>
</span></span><span class=line><span class=cl><span class=err>|</span>       <span class=err>:</span>   <span class=err>0</span><span class=nf>x00400679</span>      <span class=no>bf94074000</span>     <span class=no>mov</span> <span class=no>edi</span><span class=p>,</span> <span class=mi>0x400794</span>
</span></span><span class=line><span class=cl><span class=err>|</span>       <span class=err>:</span>   <span class=err>0</span><span class=nf>x0040067e</span>      <span class=no>b800000000</span>     <span class=no>mov</span> <span class=no>eax</span><span class=p>,</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl><span class=err>|</span>       <span class=err>:</span>   <span class=err>0</span><span class=nf>x00400683</span>      <span class=no>e8a8feffff</span>     <span class=no>call</span> <span class=no>sym.imp.__isoc99_scanf</span>
</span></span><span class=line><span class=cl><span class=err>|</span>       <span class=err>:</span>   <span class=err>0</span><span class=nf>x00400688</span>      <span class=no>b800000000</span>     <span class=no>mov</span> <span class=no>eax</span><span class=p>,</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl><span class=err>|</span>       <span class=err>:</span>   <span class=err>0</span><span class=nf>x0040068d</span>      <span class=no>e8b4ffffff</span>     <span class=no>call</span> <span class=no>sym.get_secret</span>
</span></span><span class=line><span class=cl><span class=err>|</span>       <span class=err>:</span>   <span class=err>0</span><span class=nf>x00400692</span>      <span class=mi>4889</span><span class=no>c2</span>         <span class=no>mov</span> <span class=no>rdx</span><span class=p>,</span> <span class=no>rax</span>
</span></span><span class=line><span class=cl><span class=err>|</span>       <span class=err>:</span>   <span class=err>0</span><span class=nf>x00400695</span>      <span class=mi>488</span><span class=no>d45e0</span>       <span class=no>lea</span> <span class=no>rax</span><span class=p>,</span> <span class=p>[</span><span class=no>local_20h</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=err>|</span>       <span class=err>:</span>   <span class=err>0</span><span class=nf>x00400699</span>      <span class=mi>4889</span><span class=no>d6</span>         <span class=no>mov</span> <span class=no>rsi</span><span class=p>,</span> <span class=no>rdx</span>
</span></span><span class=line><span class=cl><span class=err>|</span>       <span class=err>:</span>   <span class=err>0</span><span class=nf>x0040069c</span>      <span class=mi>4889</span><span class=no>c7</span>         <span class=no>mov</span> <span class=no>rdi</span><span class=p>,</span> <span class=no>rax</span>
</span></span><span class=line><span class=cl><span class=err>|</span>       <span class=err>:</span>   <span class=err>0</span><span class=nf>x0040069f</span>      <span class=no>e87cfeffff</span>     <span class=no>call</span> <span class=no>sym.imp.strcmp</span>         <span class=c1>; int strcmp(const char *s1, const char *s2)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=err>|</span>       <span class=err>:</span>   <span class=err>0</span><span class=nf>x004006a4</span>      <span class=mi>8945</span><span class=no>dc</span>         <span class=no>mov</span> <span class=no>dword</span> <span class=p>[</span><span class=no>local_24h</span><span class=p>],</span> <span class=no>eax</span>
</span></span><span class=line><span class=cl><span class=err>|</span>       <span class=err>:</span>   <span class=err>0</span><span class=nf>x004006a7</span>      <span class=mi>837</span><span class=no>ddc00</span>       <span class=no>cmp</span> <span class=no>dword</span> <span class=p>[</span><span class=no>local_24h</span><span class=p>],</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl><span class=err>|</span>      <span class=err>,==&lt;</span> <span class=err>0</span><span class=nf>x004006ab</span>      <span class=mi>7521</span>           <span class=no>jne</span> <span class=mi>0x4006ce</span>
</span></span><span class=line><span class=cl><span class=err>|</span>      <span class=err>|:</span>   <span class=err>0</span><span class=nf>x004006ad</span>      <span class=no>bf97074000</span>     <span class=no>mov</span> <span class=no>edi</span><span class=p>,</span> <span class=no>str.Correct</span>        <span class=c1>; 0x400797 ; &#34;Correct!&#34;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=err>|</span>      <span class=err>|:</span>   <span class=err>0</span><span class=nf>x004006b2</span>      <span class=no>e839feffff</span>     <span class=no>call</span> <span class=no>sym.imp.puts</span>           <span class=c1>; int puts(const char *s)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=err>|</span>      <span class=err>|:</span>   <span class=err>0</span><span class=nf>x004006b7</span>      <span class=mi>90</span>             <span class=no>nop</span>
</span></span><span class=line><span class=cl><span class=err>|</span>      <span class=err>|:</span>   <span class=err>0</span><span class=nf>x004006b8</span>      <span class=no>b800000000</span>     <span class=no>mov</span> <span class=no>eax</span><span class=p>,</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl><span class=err>|</span>      <span class=err>|:</span>   <span class=err>0</span><span class=nf>x004006bd</span>      <span class=mi>488</span><span class=no>b4df8</span>       <span class=no>mov</span> <span class=no>rcx</span><span class=p>,</span> <span class=no>qword</span> <span class=p>[</span><span class=no>local_8h</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=err>|</span>      <span class=err>|:</span>   <span class=err>0</span><span class=nf>x004006c1</span>      <span class=mi>6448330</span><span class=no>c2528.</span>  <span class=no>xor</span> <span class=no>rcx</span><span class=p>,</span> <span class=no>qword</span> <span class=no>fs</span><span class=p>:[</span><span class=mi>0x28</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=err>|</span>     <span class=err>,===&lt;</span> <span class=err>0</span><span class=nf>x004006ca</span>      <span class=mi>7413</span>           <span class=no>je</span> <span class=mi>0x4006df</span>
</span></span><span class=line><span class=cl><span class=err>|</span>    <span class=err>,====&lt;</span> <span class=err>0</span><span class=nf>x004006cc</span>      <span class=no>eb0c</span>           <span class=no>jmp</span> <span class=mi>0x4006da</span>
</span></span><span class=line><span class=cl><span class=err>|</span>    <span class=err>|||:</span>      <span class=c1>; JMP XREF from 0x004006ab (sym.main)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=err>|</span>    <span class=err>||`--&gt;</span> <span class=err>0</span><span class=nf>x004006ce</span>      <span class=no>bfa0074000</span>     <span class=no>mov</span> <span class=no>edi</span><span class=p>,</span> <span class=no>str.Wrong</span>          <span class=c1>; 0x4007a0 ; &#34;Wrong!&#34;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=err>|</span>    <span class=err>||</span> <span class=err>:</span>   <span class=err>0</span><span class=nf>x004006d3</span>      <span class=no>e818feffff</span>     <span class=no>call</span> <span class=no>sym.imp.puts</span>           <span class=c1>; int puts(const char *s)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=err>|</span>    <span class=err>||</span> <span class=err>`=&lt;</span> <span class=err>0</span><span class=nf>x004006d8</span>      <span class=no>eb8e</span>           <span class=no>jmp</span> <span class=mi>0x400668</span>
</span></span><span class=line><span class=cl><span class=err>|</span>    <span class=err>||</span>        <span class=c1>; JMP XREF from 0x004006cc (sym.main)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=err>|</span>    <span class=err>`----&gt;</span> <span class=err>0</span><span class=nf>x004006da</span>      <span class=no>e821feffff</span>     <span class=no>call</span> <span class=no>sym.imp.__stack_chk_fail</span> <span class=c1>; void __stack_chk_fail(void)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=err>|</span>     <span class=err>|</span>        <span class=c1>; JMP XREF from 0x004006ca (sym.main)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=err>|</span>     <span class=err>`---&gt;</span> <span class=err>0</span><span class=nf>x004006df</span>      <span class=no>c9</span>             <span class=no>leave</span>
</span></span><span class=line><span class=cl><span class=err>\</span>           <span class=err>0</span><span class=nf>x004006e0</span>      <span class=no>c3</span>             <span class=no>ret</span>
</span></span></code></pre></div><p>Lets break it down to steps:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=line><span class=cl>            <span class=c1>;-- main:
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=err>/</span> <span class=err>(</span><span class=nf>fcn</span><span class=p>)</span> <span class=no>sym.main</span> <span class=mi>144</span>
</span></span><span class=line><span class=cl><span class=err>|</span>   <span class=nf>sym.main</span> <span class=p>()</span><span class=c1>;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=err>|</span>           <span class=c1>; var int local_24h @ rbp-0x24
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=err>|</span>           <span class=c1>; var int local_20h @ rbp-0x20
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=err>|</span>           <span class=c1>; var int local_8h @ rbp-0x8
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=err>|</span>              <span class=c1>; DATA XREF from 0x0040056d (entry0)
</span></span></span></code></pre></div><p>This comment section in the beginning of the disassembled main function tells us that the function has three local variables that are in the scope of the function, indicated by the <code>local_</code> prefix. They are located in the offset of <code>rbp-0x[hexvalue]</code>. Also the <code>DATA XREF</code> tell that the function was cross referenced from the given address.</p><pre tabindex=0><code>&gt; pdf @ 0x0040056d
</code></pre><p>which outputs the entrypoint function we analyzed earlier. You can read more about cross references from <a href=http://resources.infosecinstitute.com/ida-cross-references-xrefs/>here</a>. With <strong>a</strong>nalyze <strong>f</strong>unction <strong>v</strong>ariable <strong>d</strong>isplay command, we could check out the values of the local variables e.g. when debugging the application and setting breakpoints during the process.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=line><span class=cl><span class=err>&gt;</span> <span class=nf>afvd</span>
</span></span><span class=line><span class=cl><span class=nf>var</span> <span class=no>local_8h</span> <span class=err>=</span> <span class=mi>0xfffffffffffffff8</span>  <span class=mi>0xffffffffffffffff</span>   <span class=no>........</span>
</span></span><span class=line><span class=cl><span class=nf>var</span> <span class=no>local_20h</span> <span class=err>=</span> <span class=mi>0xffffffffffffffe0</span>  <span class=mi>0xffffffffffffffff</span>   <span class=no>........</span>
</span></span><span class=line><span class=cl><span class=nf>var</span> <span class=no>local_24h</span> <span class=err>=</span> <span class=mi>0xffffffffffffffdc</span>  <span class=mi>0xffffffffffffffff</span>   <span class=no>........</span>
</span></span></code></pre></div><p>Alright, onwards.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=line><span class=cl><span class=err>|</span>           <span class=err>0</span><span class=nf>x00400651</span>      <span class=mi>55</span>             <span class=no>push</span> <span class=no>rbp</span>
</span></span><span class=line><span class=cl><span class=err>|</span>           <span class=err>0</span><span class=nf>x00400652</span>      <span class=mi>4889</span><span class=no>e5</span>         <span class=no>mov</span> <span class=no>rbp</span><span class=p>,</span> <span class=no>rsp</span>
</span></span><span class=line><span class=cl><span class=err>|</span>           <span class=err>0</span><span class=nf>x00400655</span>      <span class=mi>4883</span><span class=no>ec30</span>       <span class=no>sub</span> <span class=no>rsp</span><span class=p>,</span> <span class=mi>0x30</span>               <span class=c1>; &#39;0&#39;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=err>|</span>           <span class=err>0</span><span class=nf>x00400659</span>      <span class=mi>64488</span><span class=no>b042528.</span>  <span class=no>mov</span> <span class=no>rax</span><span class=p>,</span> <span class=no>qword</span> <span class=no>fs</span><span class=p>:[</span><span class=mi>0x28</span><span class=p>]</span>    <span class=c1>; [0x28:8]=-1 ; &#39;(&#39; ; 40
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=err>|</span>           <span class=err>0</span><span class=nf>x00400662</span>      <span class=mi>488945</span><span class=no>f8</span>       <span class=no>mov</span> <span class=no>qword</span> <span class=p>[</span><span class=no>local_8h</span><span class=p>],</span> <span class=no>rax</span>
</span></span><span class=line><span class=cl><span class=err>|</span>           <span class=err>0</span><span class=nf>x00400666</span>      <span class=mi>31</span><span class=no>c0</span>           <span class=no>xor</span> <span class=no>eax</span><span class=p>,</span> <span class=no>eax</span>
</span></span></code></pre></div><p>Base pointer is pushed to the stack to store the point where to resume the execution from and previous stack pointer value is put into to the base pointer register. Then, stack pointer is moved to reserve space for the upcoming variables (remember, stack &ldquo;grows&rdquo; downwards in the address space - hence the reduction). This is common way of function &ldquo;prologues&rdquo; in assembly.</p><p>Also it seems that a value from <code>fs</code> offset <code>0x28</code> is moved to <code>rax</code>. <code>qword</code> means that this operand has a size of a quad-word (word is 2 bytes = 8 bytes long). Then, the value at <code>rax</code> is loaded to local variable. What do the brackets mean? Effectively with <code>mov</code> opcodes, brackets mean that &ldquo;dereference the value at the given address&rdquo;. Finally, the <code>eax</code> register is zeroed.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=line><span class=cl><span class=err>|</span>       <span class=nf>.-</span><span class=err>&gt;</span> <span class=mi>0x00400668</span>      <span class=no>bf83074000</span>     <span class=no>mov</span> <span class=no>edi</span><span class=p>,</span> <span class=no>str.Enter_password</span><span class=p>:</span> <span class=c1>; 0x400783 ; &#34;Enter password: &#34;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=err>|</span>       <span class=err>:</span>   <span class=err>0</span><span class=nf>x0040066d</span>      <span class=no>e87efeffff</span>     <span class=no>call</span> <span class=no>sym.imp.puts</span>           <span class=c1>; int puts(const char *s)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=err>|</span>       <span class=err>:</span>   <span class=err>0</span><span class=nf>x00400672</span>      <span class=mi>488</span><span class=no>d45e0</span>       <span class=no>lea</span> <span class=no>rax</span><span class=p>,</span> <span class=p>[</span><span class=no>local_20h</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=err>|</span>       <span class=err>:</span>   <span class=err>0</span><span class=nf>x00400676</span>      <span class=mi>4889</span><span class=no>c6</span>         <span class=no>mov</span> <span class=no>rsi</span><span class=p>,</span> <span class=no>rax</span>
</span></span><span class=line><span class=cl><span class=err>|</span>       <span class=err>:</span>   <span class=err>0</span><span class=nf>x00400679</span>      <span class=no>bf94074000</span>     <span class=no>mov</span> <span class=no>edi</span><span class=p>,</span> <span class=mi>0x400794</span>
</span></span><span class=line><span class=cl><span class=err>|</span>       <span class=err>:</span>   <span class=err>0</span><span class=nf>x0040067e</span>      <span class=no>b800000000</span>     <span class=no>mov</span> <span class=no>eax</span><span class=p>,</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl><span class=err>|</span>       <span class=err>:</span>   <span class=err>0</span><span class=nf>x00400683</span>      <span class=no>e8a8feffff</span>     <span class=no>call</span> <span class=no>sym.imp.__isoc99_scanf</span>
</span></span><span class=line><span class=cl><span class=err>|</span>       <span class=err>:</span>   <span class=err>0</span><span class=nf>x00400688</span>      <span class=no>b800000000</span>     <span class=no>mov</span> <span class=no>eax</span><span class=p>,</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl><span class=err>|</span>       <span class=err>:</span>   <span class=err>0</span><span class=nf>x0040068d</span>      <span class=no>e8b4ffffff</span>     <span class=no>call</span> <span class=no>sym.get_secret</span>
</span></span></code></pre></div><p>The string &ldquo;Enter password: " is moved to <code>edi</code> and an imported function puts is called, which outputs the string to the <code>stdout</code>. Then, the computed address of a local variable is set in <code>rax</code>. <code>lea</code>, <strong>l</strong>oad <strong>e</strong>ffective <strong>a</strong>ddress works pretty much similarly as <code>mov</code> but instead of loading or moving the value, the calculated effective address is moved to the target register instead, which can be dereferenced later.</p><p>At the end, <code>scanf</code> is called for user input. After that, <code>get_secret</code> is called, which seems to be interesting based on its name.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=line><span class=cl><span class=err>|</span>       <span class=err>:</span>   <span class=err>0</span><span class=nf>x00400692</span>      <span class=mi>4889</span><span class=no>c2</span>         <span class=no>mov</span> <span class=no>rdx</span><span class=p>,</span> <span class=no>rax</span>
</span></span><span class=line><span class=cl><span class=err>|</span>       <span class=err>:</span>   <span class=err>0</span><span class=nf>x00400695</span>      <span class=mi>488</span><span class=no>d45e0</span>       <span class=no>lea</span> <span class=no>rax</span><span class=p>,</span> <span class=p>[</span><span class=no>local_20h</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=err>|</span>       <span class=err>:</span>   <span class=err>0</span><span class=nf>x00400699</span>      <span class=mi>4889</span><span class=no>d6</span>         <span class=no>mov</span> <span class=no>rsi</span><span class=p>,</span> <span class=no>rdx</span>
</span></span><span class=line><span class=cl><span class=err>|</span>       <span class=err>:</span>   <span class=err>0</span><span class=nf>x0040069c</span>      <span class=mi>4889</span><span class=no>c7</span>         <span class=no>mov</span> <span class=no>rdi</span><span class=p>,</span> <span class=no>rax</span>
</span></span><span class=line><span class=cl><span class=err>|</span>       <span class=err>:</span>   <span class=err>0</span><span class=nf>x0040069f</span>      <span class=no>e87cfeffff</span>     <span class=no>call</span> <span class=no>sym.imp.strcmp</span>         <span class=c1>; int strcmp(const char *s1, const char *s2)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=err>|</span>       <span class=err>:</span>   <span class=err>0</span><span class=nf>x004006a4</span>      <span class=mi>8945</span><span class=no>dc</span>         <span class=no>mov</span> <span class=no>dword</span> <span class=p>[</span><span class=no>local_24h</span><span class=p>],</span> <span class=no>eax</span>
</span></span><span class=line><span class=cl><span class=err>|</span>       <span class=err>:</span>   <span class=err>0</span><span class=nf>x004006a7</span>      <span class=mi>837</span><span class=no>ddc00</span>       <span class=no>cmp</span> <span class=no>dword</span> <span class=p>[</span><span class=no>local_24h</span><span class=p>],</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl><span class=err>|</span>      <span class=err>,==&lt;</span> <span class=err>0</span><span class=nf>x004006ab</span>      <span class=mi>7521</span>           <span class=no>jne</span> <span class=mi>0x4006ce</span>
</span></span></code></pre></div><p>Based on the four following instructions before <code>strcmp</code> call, seems like the value of the function <code>get_secret</code> is stored in <code>rax</code> and is moved to <code>rdx</code>. The value of the user input on the other hand is stored in the local variable and its effective address is loaded to <code>rax</code>. Then, the values to be compared are loaded to <code>rsi</code> and <code>rdi</code> respectively and <code>strcmp</code> is called to compare them. Result of this function call is stored in <code>eax</code> and then it is compared. Values of these comparisons are stored in flag registers that were discussed in the previous post. If the comparison failed, jne jumps to the specified memory address and following sequence is executed:</p><pre tabindex=0><code>|    ||`--&gt; 0x004006ce      bfa0074000     mov edi, str.Wrong          ; 0x4007a0 ; &#34;Wrong!&#34;
|    || :   0x004006d3      e818feffff     call sym.imp.puts           ; int puts(const char *s)
|    || `=&lt; 0x004006d8      eb8e           jmp 0x400668
</code></pre><p>So a string &ldquo;Wrong!&rdquo; is printed to stdout and execution flow jumps to the given address, which is in the beginning of the main function.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=line><span class=cl><span class=err>|</span>      <span class=err>|:</span>   <span class=err>0</span><span class=nf>x004006ad</span>      <span class=no>bf97074000</span>     <span class=no>mov</span> <span class=no>edi</span><span class=p>,</span> <span class=no>str.Correct</span>        <span class=c1>; 0x400797 ; &#34;Correct!&#34;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=err>|</span>      <span class=err>|:</span>   <span class=err>0</span><span class=nf>x004006b2</span>      <span class=no>e839feffff</span>     <span class=no>call</span> <span class=no>sym.imp.puts</span>           <span class=c1>; int puts(const char *s)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=err>|</span>      <span class=err>|:</span>   <span class=err>0</span><span class=nf>x004006b7</span>      <span class=mi>90</span>             <span class=no>nop</span>
</span></span><span class=line><span class=cl><span class=err>|</span>      <span class=err>|:</span>   <span class=err>0</span><span class=nf>x004006b8</span>      <span class=no>b800000000</span>     <span class=no>mov</span> <span class=no>eax</span><span class=p>,</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl><span class=err>|</span>      <span class=err>|:</span>   <span class=err>0</span><span class=nf>x004006bd</span>      <span class=mi>488</span><span class=no>b4df8</span>       <span class=no>mov</span> <span class=no>rcx</span><span class=p>,</span> <span class=no>qword</span> <span class=p>[</span><span class=no>local_8h</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=err>|</span>      <span class=err>|:</span>   <span class=err>0</span><span class=nf>x004006c1</span>      <span class=mi>6448330</span><span class=no>c2528.</span>  <span class=no>xor</span> <span class=no>rcx</span><span class=p>,</span> <span class=no>qword</span> <span class=no>fs</span><span class=p>:[</span><span class=mi>0x28</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=err>|</span>     <span class=err>,===&lt;</span> <span class=err>0</span><span class=nf>x004006ca</span>      <span class=mi>7413</span>           <span class=no>je</span> <span class=mi>0x4006df</span>
</span></span><span class=line><span class=cl><span class=err>|</span>    <span class=err>,====&lt;</span> <span class=err>0</span><span class=nf>x004006cc</span>      <span class=no>eb0c</span>           <span class=no>jmp</span> <span class=mi>0x4006da</span>
</span></span><span class=line><span class=cl><span class=err>|</span>    <span class=err>|||:</span>      <span class=c1>; JMP XREF from 0x004006ab (sym.main)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=err>|</span>    <span class=err>||`--&gt;</span> <span class=err>0</span><span class=nf>x004006ce</span>      <span class=no>bfa0074000</span>     <span class=no>mov</span> <span class=no>edi</span><span class=p>,</span> <span class=no>str.Wrong</span>          <span class=c1>; 0x4007a0 ; &#34;Wrong!&#34;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=err>|</span>    <span class=err>||</span> <span class=err>:</span>   <span class=err>0</span><span class=nf>x004006d3</span>      <span class=no>e818feffff</span>     <span class=no>call</span> <span class=no>sym.imp.puts</span>           <span class=c1>; int puts(const char *s)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=err>|</span>    <span class=err>||</span> <span class=err>`=&lt;</span> <span class=err>0</span><span class=nf>x004006d8</span>      <span class=no>eb8e</span>           <span class=no>jmp</span> <span class=mi>0x400668</span>
</span></span><span class=line><span class=cl><span class=err>|</span>    <span class=err>||</span>        <span class=c1>; JMP XREF from 0x004006cc (sym.main)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=err>|</span>    <span class=err>`----&gt;</span> <span class=err>0</span><span class=nf>x004006da</span>      <span class=no>e821feffff</span>     <span class=no>call</span> <span class=no>sym.imp.__stack_chk_fail</span> <span class=c1>; void __stack_chk_fail(void)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=err>|</span>     <span class=err>|</span>        <span class=c1>; JMP XREF from 0x004006ca (sym.main)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=err>|</span>     <span class=err>`---&gt;</span> <span class=err>0</span><span class=nf>x004006df</span>      <span class=no>c9</span>             <span class=no>leave</span>
</span></span><span class=line><span class=cl><span class=err>\</span>           <span class=err>0</span><span class=nf>x004006e0</span>      <span class=no>c3</span>             <span class=no>ret</span>
</span></span></code></pre></div><p>Rest of the code should be now quite understandable based on some of the basic principles we learned on our way here. The left side arrows indicate the flow within the main function and <code>je</code> and <code>jmp</code> opcodes are defining the execution flow. When the user gives the correct string, the function leaves the loop and returns, effectively ending our main loop.</p><h2 id=finding-the-secret>Finding the secret<a hidden class=anchor aria-hidden=true href=#finding-the-secret>#</a></h2><p>Now we have seen the main function and know how to navigate around a bit. There are multiple ways of doing this of course, but for practice lets check out what the <code>get_secret()</code> function does as it sounds interesting.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=line><span class=cl><span class=err>&gt;</span> <span class=nf>s</span> <span class=no>sym.get_secret</span>
</span></span><span class=line><span class=cl><span class=err>[0</span><span class=nf>x00400646</span><span class=p>]</span><span class=err>&gt;</span> <span class=no>pdf</span>
</span></span><span class=line><span class=cl><span class=err>/</span> <span class=err>(</span><span class=nf>fcn</span><span class=p>)</span> <span class=no>sym.get_secret</span> <span class=mi>11</span>
</span></span><span class=line><span class=cl><span class=err>|</span>   <span class=nf>sym.get_secret</span> <span class=p>()</span><span class=c1>;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=err>|</span>              <span class=c1>; CALL XREF from 0x0040068d (sym.main)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=err>|</span>           <span class=err>0</span><span class=nf>x00400646</span>      <span class=mi>55</span>             <span class=no>push</span> <span class=no>rbp</span>
</span></span><span class=line><span class=cl><span class=err>|</span>           <span class=err>0</span><span class=nf>x00400647</span>      <span class=mi>4889</span><span class=no>e5</span>         <span class=no>mov</span> <span class=no>rbp</span><span class=p>,</span> <span class=no>rsp</span>
</span></span><span class=line><span class=cl><span class=err>|</span>           <span class=err>0</span><span class=nf>x0040064a</span>      <span class=no>b874074000</span>     <span class=no>mov</span> <span class=no>eax</span><span class=p>,</span> <span class=no>str.s3cr37p455w0rd</span> <span class=c1>; 0x400774 ; &#34;s3cr37p455w0rd&#34;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=err>|</span>           <span class=err>0</span><span class=nf>x0040064f</span>      <span class=mi>5</span><span class=no>d</span>             <span class=no>pop</span> <span class=no>rbp</span>
</span></span><span class=line><span class=cl><span class=err>\</span>           <span class=err>0</span><span class=nf>x00400650</span>      <span class=no>c3</span>             <span class=no>ret</span>
</span></span></code></pre></div><p>Seems like this function is quite simple: Base pointer is pushed to the stack to store the return address where the execution of the program will continue, stack pointer is moved to point to the current frame and a quite distinguishing string variable is moved to the <code>eax</code> register. Finally the base pointer is popped back from the stack and function returns, resuming the execution of our application.</p><p>Lets try this password out:</p><pre tabindex=0><code>$ ./a.out
Enter password:
s3cr37p455w0rd
Correct!
</code></pre><h2 id=alternative-ways-file-info-revisited>Alternative ways: File info revisited<a hidden class=anchor aria-hidden=true href=#alternative-ways-file-info-revisited>#</a></h2><p>I intentionally skipped one useful info command: <code>iz</code>. This prints information about the strings located in the binary itself. This though reveals also the answer to our top-secret exercise. Whoops! Why? Well, it&rsquo;s stored hard-coded as a variable within the binary itself.</p><pre tabindex=0><code>&gt; iz
000 0x00000774 0x00400774  14  15 (.rodata) ascii s3cr37p455w0rd
001 0x00000783 0x00400783  16  17 (.rodata) ascii Enter password:
002 0x00000797 0x00400797   8   9 (.rodata) ascii Correct!
003 0x000007a0 0x004007a0   6   7 (.rodata) ascii Wrong!
</code></pre><p>Still, this can be a very useful command to remember as well when debugging or reversing software. Also if you explored the flag more earlier, you might have done:</p><pre tabindex=0><code>&gt; fs strings; f
0x00400774 15 str.s3cr37p455w0rd
0x00400783 17 str.Enter_password:
0x00400797 9 str.Correct
0x004007a0 7 str.Wrong
</code></pre><h2 id=extra-stack-canaries>Extra: Stack canaries?<a hidden class=anchor aria-hidden=true href=#extra-stack-canaries>#</a></h2><p>In the original lab exercise, one thing caught my eye: it was compiled with stack protection enabled, which is used by e.g. as a gcc flag <code>-fstack-protect-all</code>. This resulted in an interesting program initialization assembly:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=line><span class=cl><span class=err>|</span>    <span class=err>`----&gt;</span> <span class=err>0</span><span class=nf>x004006da</span>      <span class=no>e821feffff</span>     <span class=no>call</span> <span class=no>sym.imp.__stack_chk_fail</span> <span class=c1>; void __stack_chk_fail(void)
</span></span></span></code></pre></div><p>What are stack canaries? <a href=https://xorl.wordpress.com/2010/10/14/linux-glibc-stack-canary-values/>This blog post</a> was an excellent wrap-up of the topic. In short, a stack canary is a feature in binaries to protect from malicious buffer overflows on variables that have been allocated in stack.</p><h2 id=conclusions>Conclusions<a hidden class=anchor aria-hidden=true href=#conclusions>#</a></h2><p>Well, there it is! Understanding of basics of computer architectures, memory handling in assembly were visited, and how to navigate and use basic functionalities of Radare. Time to dive into reverse engineering on real-world software binaries or write some own to practice with!</p><p>One options would be to look with a search engine for capture-the-flag exercises and challenges, as well as excellent Radare tutorials out there. CTF challenges are good way to start prepping puzzle skills hand-in-hand with binary analysis and can really twist your brains.</p><h2 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h2><ul><li><a href=https://github.com/s4n7h0/Practical-Reverse-Engineering-using-Radare2/>Github Project - Practical Reverse Engineering using Radare2</a></li><li><a href=https://grugq.github.io/docs/phrack-58-05.txt>Phrack: Armouring the ELF: Binary encryption on the UNIX platform</a></li><li><a href=http://www.vxdev.com/docs/vx55man/diab5.0ppc/x-elf_fo.htm#3001084>Executable and Linking Format (ELF)</a></li><li><a href=https://en.wikipedia.org/wiki/Data_structure_alignment>Wikipedia: Data structure alignment</a></li><li><a href=https://en.wikipedia.org/wiki/Position-independent_code>Wikipedia: Position-independent code</a></li><li><a href=https://en.wikipedia.org/wiki/Relocation_(computing)>Wikipedia: Relocatable binary</a></li><li><a href=https://en.wikipedia.org/wiki/Rpath>Wikipedia: Rpath</a></li><li><a href=https://en.wikipedia.org/wiki/Endianness>Wikipedia: Endianness</a></li><li><a href=https://en.wikipedia.org/wiki/Executable_and_Linkable_Format>Wikipedia: Executable and Linkable Format</a></li><li><a href=http://dbp-consulting.com/tutorials/debugging/linuxProgramStartup.html>Patric Horgan: Linux x86 Program Start Up or - How the heck do we get to main()?</a></li><li><a href=https://www.megabeets.net/a-journey-into-radare-2-part-1/>Megabeets: A Journey Into Radare2 Part 1</a></li><li><a href=https://xorl.wordpress.com/2010/10/14/linux-glibc-stack-canary-values/>xorl %eax, %eax: Linux Glibc - Stack Canary Values</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://kraashen.github.io/tags/reverse-engineering/>Reverse Engineering</a></li><li><a href=https://kraashen.github.io/tags/radare/>Radare</a></li><li><a href=https://kraashen.github.io/tags/studying/>Studying</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://kraashen.github.io/>tracing bytes</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>