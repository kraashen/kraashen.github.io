<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Raspberry Pi Web Server Using Caddy and Github Webhooks | tracing bytes</title>
<meta name=keywords content="raspberrypi,tweaking"><meta name=description content="After setting up the DMZ in my home network, it was time to get hands on with the actual server. I heard of a web server called Caddy, which is a HTTP/2 HTTPS-by-default web server written in Go. I got into Go as a programming language some time ago recently and I was a bit excited about a possibility of running a production capable web server with it on a Raspberry Pi."><meta name=author content><link rel=canonical href=https://kraashen.github.io/posts/2017-10-28-raspberry-pi-web-server-using-caddy-with-git-webhooks/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://kraashen.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://kraashen.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://kraashen.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://kraashen.github.io/apple-touch-icon.png><link rel=mask-icon href=https://kraashen.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://kraashen.github.io/posts/2017-10-28-raspberry-pi-web-server-using-caddy-with-git-webhooks/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Raspberry Pi Web Server Using Caddy and Github Webhooks"><meta property="og:description" content="After setting up the DMZ in my home network, it was time to get hands on with the actual server. I heard of a web server called Caddy, which is a HTTP/2 HTTPS-by-default web server written in Go. I got into Go as a programming language some time ago recently and I was a bit excited about a possibility of running a production capable web server with it on a Raspberry Pi."><meta property="og:type" content="article"><meta property="og:url" content="https://kraashen.github.io/posts/2017-10-28-raspberry-pi-web-server-using-caddy-with-git-webhooks/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2017-10-28T16:57:26+03:00"><meta property="article:modified_time" content="2017-10-28T16:57:26+03:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Raspberry Pi Web Server Using Caddy and Github Webhooks"><meta name=twitter:description content="After setting up the DMZ in my home network, it was time to get hands on with the actual server. I heard of a web server called Caddy, which is a HTTP/2 HTTPS-by-default web server written in Go. I got into Go as a programming language some time ago recently and I was a bit excited about a possibility of running a production capable web server with it on a Raspberry Pi."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://kraashen.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Raspberry Pi Web Server Using Caddy and Github Webhooks","item":"https://kraashen.github.io/posts/2017-10-28-raspberry-pi-web-server-using-caddy-with-git-webhooks/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Raspberry Pi Web Server Using Caddy and Github Webhooks","name":"Raspberry Pi Web Server Using Caddy and Github Webhooks","description":"After setting up the DMZ in my home network, it was time to get hands on with the actual server. I heard of a web server called Caddy, which is a HTTP/2 HTTPS-by-default web server written in Go. I got into Go as a programming language some time ago recently and I was a bit excited about a possibility of running a production capable web server with it on a Raspberry Pi.","keywords":["raspberrypi","tweaking"],"articleBody":"After setting up the DMZ in my home network, it was time to get hands on with the actual server. I heard of a web server called Caddy, which is a HTTP/2 HTTPS-by-default web server written in Go. I got into Go as a programming language some time ago recently and I was a bit excited about a possibility of running a production capable web server with it on a Raspberry Pi.\nRasPis have always been a tempting choice for me as a very affordable platform for me to either tinker with any projects or have services running on them. Raspberry Pi 3 packs quite a bunch of processing power and features nowadays, and I heard a recommendation from my friend of them for web server use cases. I got inspired as well and it seemed like a good option for hosting a website without losing the server availability if there is something else being processed on the server.\nSetup I divided the process of the setup into couple of phases:\nUser account creation and separation. Clean up default pi user. Basic firewalling of the server using iptables, fail2ban Use SSH key for remote login only Configure automatic updates Define static IP addressing, study how it works on Pi, what services handle it etc, how interface naming works on Debian distros. Investigate what services Pi runs out of the box; Why are they needed or why they are not needed. Remove unneeded services. Deploy and configure Caddy. While it uses Let’s Encrypt by default, study how it works and why it works as it does. Configure Github webhooks “Audit” the server Networking and interfaces As the server will be hosting a website, it will need a static IP address Finnish DynDNS. In Raspbian, there is a client called dhcpcd DHCP client enabled by default, and there are couple of ways handling the static IP addressing of the server. One way would be to just disable the dhcpcd and use /etc/network/interfaces instead or configure dhcpcd to use static IP address instead. Running a DHCP client to get a static IP address was not needed in this kind of wired environment, so I went with the interfaces way for my case.\n/etc/network/interfaces: auto [interface] iface [interface] inet static address [static server address configured in the router port forward rules] gateway [router DMZ gateway] netmask 255.255.255.0 After wondering why this did not work it was fun to find out that in Debian Stretch, interface naming has changed by default:\nThe installer and newly installed systems will use a new standard naming scheme for network interfaces instead of eth0, eth1, etc. The old naming method suffered from enumeration race conditions that made it possible for interface names to change unexpectedly and is incompatible with mounting the root filesystem read-only. The new enumeration method relies on more sources of information, to produce a more repeatable outcome. It uses the firmware/BIOS provided index numbers and then tries PCI card slot numbers, producing names like ens0 or enp1s1 (ethernet) or wlp3s0 (wlan). USB devices, which can be added to the system at any time, will have names based upon their ethernet MAC addresses.\nThe interface name needs to be of this syntax. It can be found out e.g. checking by ifconfig, or it must be changed manually to the legacy format by including/editing a udev rule in /etc/udev/rules.d/ directory. While there are plenty of resources on how to achieve this, note that it will be deprecated starting Debian 10.\nMore detailed explanation is in here, but the key point is that fixed names based on firmware, topology, and location information has advantage of being consistent across changes in the environment e.g. including reboots, hardware changes.\nNow I also needed to set up basic iptables and fail2ban rules to control traffic to the server and reflect my settings done in the router. This was a handy post to study and implement basic filtering rules, which I modified a bit for my needs. It was interesting to notice that the rules needed to be loaded to iptables by running iptables-restore \u003c /etc/iptables.rules and a file /etc/network/if-pre-up.d/iptables-init with +x permissions is required to recover iptables rules when the server is rebooted.\nAutomatic updates Unanttended upgrades seemed like a handy way to keep the server up-to-date. After installing the package running apt install unattended-upgrades the configuration file in /etc/apt/apt.conf.d/50unattended-upgrades required a minor tweak as default origin was set to Debian instead of Raspbian:\n... Unattended-Upgrade::Origins-Pattern { \"origin=Raspbian,codename=${distro_codename} } ... Disable unneeded services As the Pi will be running purely as a web server, there were handful of features and services that can be just disabled. Here’s some for starters.\nDisable BlueTooth and WiFi during bootup:\n/boot/config.txt ... dtoverlay=pi3-disable-bt dtoverlay=pi3-disable-wifi Disable unneeded systemd services:\n# disable dhcpcd systemctl disable dhcpcd.service \u0026\u0026 systemctl stop dhcpcd.service # Bluetooth-related services systemctl disable bluealsa.service \u0026\u0026 systemctl stop bluealsa.service systemctl disable hciuart.service \u0026\u0026 systemctl stop hciuart.service systemctl disable bluetooth.service \u0026\u0026 systemctl stop bluetooth.service # Avahi is an open source implementation of Bonjour/Zeroconf protocol for service discovery. systemctl disable avahi-daemon.service \u0026\u0026 systemctl stop avahi-daemon.service # No sound needed and also disabled in boot configured earlier systemctl disable alsa-restore.service \u0026\u0026 systemctl stop alsa-restore.service There might still be unneeded services left on my RasPi, but I’ll add them here afterwards as I find more. :-)\nCaddy and Hugo Caddy is a HTTP/2 web server with support for automatic HTTPS using Let’s Encrypt certificates. While it would not be tedious to set up a battle-hardened nginx or Apache using the same certificate provider, I wanted to give a shot at Caddy due to a recommendation from a friend. Besides, it’s written in Go (yes, I am a bit biased to try new tech), which made me more curious for my use case as a personal web server.\nInstalling hugo is possible using apt, but the version was a bit outdated at the time of writing this post. As instructed in the Hugo Github Issue #3995, it was possible to use the ARM architecture binary straight from the releases in the repository.\nLet’s Encrypt Let’s Encrypt (LE) is a certificate authority founded by EFF, Mozilla Foundation et al. whose mission is to allow easy and fast deployment of X.509 certificates. The project aims to make encrypted connections ubiquitous and being completely transparent of the certificate issuances. The approach to the issuance process is interesting, and I really recommend reading it from Let’s Encrypt documentation.\nTo sum it up, Let’s Encrypt together with Automatic Certificate Management Environment protocol are the basis to handle requesting, creation, issuance, and validation without human intervention. Domain validation is based on a challenge that the LE server sends to the client (your server) that is requesting a certificate. By proving these challenges that you actually host the server in the domain and after the key authorization, the client is allowed to do certificate management for the domain and can request for a certificate. Caddy handles all this automatically, but it would require just two shell commands to do manually as well.\nConfiguration Caddy is quite straightforward to install and configure:\n# git and hugo submodules are needed: git for webhook, I hugo for compiling and deploying static website so it's optional. curl https://getcaddy.com | bash -s http.git,http.hugo Basic configuration is also quite simple and HTTP is enabled by default, which is quite beautiful. Note also that HSTS header needs to be added manually. In short, this tells web browsers to use only HTTPS to access the site. If you have subdomains, refer to the Mozilla documentation for more details.\ndomain { root /var/www/domain tls [mail-address] header / { Strict-Transport-Security \"max-age=31536000;\" } } That’s all that is needed for basic hosting of a website. Now Caddy should be run as separate user, which is commonly www-data, and as a daemon on the background. Caddy documentations have a nice template how this is done using systemd which I also ended up using. You can find the documentation for this at https://github.com/mholt/caddy/tree/master/dist/init/linux-systemd, which also includes instructions to set up the www-data user properly.\nAs in documentation, the Caddy binary needs the ability to bind to privileged ports 80 and 443. cap_net_bind_service does exactly this\nsetcap 'cap_net_bind_service=+ep' /usr/local/bin/caddy After this, I needed to check, study, edit, and deploy the caddy.service file accordingly and enable these parameters in the configuration.\nCapabilityBoundingSet=CAP_NET_BIND_SERVICE AmbientCapabilities=CAP_NET_BIND_SERVICE NoNewPrivileges=true At least I had issues starting Caddy as a service due to that it was not able to bind to the ports 80 and 443. This ticket in Caddy Community was quite helpful: https://caddy.community/t/caddy-wont-start-could-not-start-http-server-for-challenge-listen-tcp-80-bind-permission-denied/2543/2\nGithub Webhooks Now that the web server is running and serves the website properly, it would be nice to have something else than Hello World as content. I use Hugo as main platform for creating website content. It’s a static website framework written - surprise - Go. The posts are written in Markdown which is compiled to a static website. It also has already quite a handful of themes available as well from the community.\nI wanted to automate the deployment flow in a way that I could make blog posts anywhere with my devices with a text editor and publish them on my server using git without need to interact with the server. One way to do this are Git webhooks. So the workflow goes about like this:\nBlog posts are in Markdown in a private git repository (access using SSH) Edit posts locally and push changes to git With every push to master branch from your device, posts that are not drafted should be published The server has a Git webhook configured that receives a notification of activity in the branch The server pulls latest revision of the site The server builds new version of the site and deploys it Caddy has a plugin support for Git webhooks, which was installed earlier. Now this requires couple of more lines to the configuration as well as creation of a SSH keypair for www-data user and activating Git webhook to the repository. Note that if your site is in a public git repository, you can also skip the key creation and configuration and use the public HTTPS URL instead.\nsudo su www-data -s /bin/bash mkdir -p /srv/www/.ssh chmod 700 /srv/www/.ssh ssh-keygen -t rsa -b 4096 /srv/www/.ssh/github_webhook_key # check that permissions are 644 for the public key, 600 for the private key After the key creation the Caddyfile needs to be edited to use the git plugin and access the repository using the private key which we created earlier. One handy way to create a secret key is to use openssl rand -base64 32, but there are definitely as many ways to create it as there are developers out there in the wild.\n/etc/caddy/Caddyfile domain { root /var/www/site tls [mail] git git@github.com:[account]/[repository].git { hook /webhook [SECRET_KEY] path /tmp/site key /srv/www/.ssh/github_webhook_key then hugo --destination=/var/www/site --cleanDestinationDir } header / { Strict-Transport-Security \"max-age=315360000;\" } } All these operations in the configuration are performed as www-data user using which the Caddy is running. After this, Caddy needs to be restarted: systemctl restart caddy.service. Now the webhook and SSH key needs to be configured to the repository in Github.com. Open up your private repository settings and select “webhooks”. Select “Add webhook” and fill up the settings:\nPayload URL: https://your.site.domain/webhook (the path was configured for the webhook) Content type: application/json (Caddy seemed to require this?) Secret: SECRET_KEY which was inserted in the Caddyfile configuration Select “Just the push event”, it’s enough for the site updates. Read permissions are enough for this use to just update the hosted site, so the SSH key can be added to “Deploy keys” with read-only access. Read more at: Github documentation on Webhook creation.\nAuditing Huzzah! Now the web server is hosting the static website. Now what? It would be also fun to check out how the server fares out in the wild, so it was fun to do even basic level auditing. While I’m not a huge fan of “checkbox security”, I’d recommend at minimum running nmap and also found out about lynis for auditing. Auditing my own servers was fun, and these tools are something to start from something.\nConclusions Well, this setup was a rabbit hole after all: After starting with something, new concepts led to another and I found myself reading hours of systemd, iptables, and Debian networking internals documentations at 2 AM in the night. Also from auditing point of view, Caddy feels like an interesting fuzzing target. It uses Go’s standard library for HTTP functionalities and the list of Caddy’s capabilities is quite long, which might be interesting to fuzz.\nI could have also set up the web server in a separate Docker container but as I won’t be running other services (yet) on the server, it felt a bit overkill. From security point of view, also Docker containers don’t work as 100% proof isolation from the system even if it might provide some level of isolation e.g. from privilege escalation. Might be still an interesting project to do some day and it would provide more consistent backup mechanisms to restore the server in case anything goes wrong. One improvement task would also be to deploy Cloudformation in front of the server, as the caching would also save card I/O on the Pi. Deploying SELinux as well would be an interesting project to study at some point. It would also be great to have better visibility and monitoring to server logs, and logging could be more verbose for diagnostics.\nIt was also interesting to notice that while using a system account feels a bit questionable for repository syncing, I did not find a way to configure Caddy to use a separate sync user to pull the Git repository.\nFurther reading Freedesktop.org: Predictable Network Interface Names\nDebian: Network Configuration\nDebian: Unattended Upgrades\n","wordCount":"2299","inLanguage":"en","datePublished":"2017-10-28T16:57:26+03:00","dateModified":"2017-10-28T16:57:26+03:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://kraashen.github.io/posts/2017-10-28-raspberry-pi-web-server-using-caddy-with-git-webhooks/"},"publisher":{"@type":"Organization","name":"tracing bytes","logo":{"@type":"ImageObject","url":"https://kraashen.github.io/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://kraashen.github.io/ accesskey=h title="tracing bytes (Alt + H)">tracing bytes</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://kraashen.github.io/ title=Home><span>Home</span></a></li><li><a href=https://kraashen.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://kraashen.github.io/snippets/ title=Snippets><span>Snippets</span></a></li><li><a href=https://kraashen.github.io/my-library/ title="My Library"><span>My Library</span></a></li><li><a href=https://kraashen.github.io/interests/ title=Interests><span>Interests</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Raspberry Pi Web Server Using Caddy and Github Webhooks</h1><div class=post-meta><span title='2017-10-28 16:57:26 +0300 +0300'>October 28, 2017</span></div></header><div class=post-content><p>After setting up the DMZ in my home network, it was time to get hands on with the actual server. I heard of a web server called Caddy, which is a HTTP/2 HTTPS-by-default web server written in Go. I got into Go as a programming language some time ago recently and I was a bit excited about a possibility of running a production capable web server with it on a Raspberry Pi.</p><p>RasPis have always been a tempting choice for me as a very affordable platform for me to either tinker with any projects or have services running on them. Raspberry Pi 3 <a href=https://www.raspberrypi.org/magpi/raspberry-pi-3-specs-benchmarks/>packs quite a bunch of processing power and features</a> nowadays, and I heard a recommendation from my friend of them for web server use cases. I got inspired as well and it seemed like a good option for hosting a website without losing the server availability if there is something else being processed on the server.</p><h2 id=setup>Setup<a hidden class=anchor aria-hidden=true href=#setup>#</a></h2><p>I divided the process of the setup into couple of phases:</p><ul><li>User account creation and separation. Clean up default <code>pi</code> user.</li><li>Basic firewalling of the server using <code>iptables</code>, <code>fail2ban</code></li><li>Use SSH key for remote login only</li><li>Configure automatic updates</li><li>Define static IP addressing, study how it works on Pi, what services handle it etc, how interface naming works on Debian distros.</li><li>Investigate what services Pi runs out of the box; Why are they needed or why they are not needed. Remove unneeded services.</li><li>Deploy and configure Caddy.</li><li>While it uses Let&rsquo;s Encrypt by default, study how it works and why it works as it does.</li><li>Configure Github webhooks</li><li>&ldquo;Audit&rdquo; the server</li></ul><h3 id=networking-and-interfaces>Networking and interfaces<a hidden class=anchor aria-hidden=true href=#networking-and-interfaces>#</a></h3><p>As the server will be hosting a website, it will need a static IP address <a href=https://www.dy.fi>Finnish DynDNS</a>. In Raspbian, there is a client called <code>dhcpcd</code> DHCP client enabled by default, and there are couple of ways handling the static IP addressing of the server. One way would be to just disable the <em>dhcpcd</em> and use <code>/etc/network/interfaces</code> instead or configure <em>dhcpcd</em> to use static IP address instead. Running a DHCP client to get a static IP address was not needed in this kind of wired environment, so I went with the interfaces way for my case.</p><pre tabindex=0><code>/etc/network/interfaces:

auto [interface]
iface [interface] inet static
    address [static server address configured in the router port forward rules]
    gateway [router DMZ gateway]
    netmask 255.255.255.0
</code></pre><p>After wondering why this did not work it was fun to find out that in Debian Stretch, <a href=https://www.debian.org/releases/stable/amd64/release-notes/ch-whats-new.en.html#new-interface-names>interface naming has changed by default</a>:</p><blockquote><p>The installer and newly installed systems will use a new standard naming scheme for network interfaces instead of eth0, eth1, etc. The old naming method suffered from enumeration race conditions that made it possible for interface names to change unexpectedly and is incompatible with mounting the root filesystem read-only. The new enumeration method relies on more sources of information, to produce a more repeatable outcome. It uses the firmware/BIOS provided index numbers and then tries PCI card slot numbers, producing names like ens0 or enp1s1 (ethernet) or wlp3s0 (wlan). USB devices, which can be added to the system at any time, will have names based upon their ethernet MAC addresses.</p></blockquote><p>The interface name needs to be of this syntax. It can be found out e.g. checking by <code>ifconfig</code>, or it must be changed manually to the legacy format by including/editing a udev rule in <code>/etc/udev/rules.d/</code> directory. While there are plenty of resources on how to achieve this, note that <a href=https://lists.debian.org/debian-user/2017/07/msg01453.html>it will be deprecated starting Debian 10</a>.</p><p>More detailed explanation is in <a href=https://www.freedesktop.org/wiki/Software/systemd/PredictableNetworkInterfaceNames/>here</a>, but the key point is that fixed names based on firmware, topology, and location information has advantage of being consistent across changes in the environment e.g. including reboots, hardware changes.</p><p>Now I also needed to set up basic <em>iptables</em> and <em>fail2ban</em> rules to control traffic to the server and reflect my settings done in the router. <a href=http://alexdberg.blogspot.fi/2012/11/creating-public-web-server-on-raspberry.html>This</a> was a handy post to study and implement basic filtering rules, which I modified a bit for my needs. It was interesting to notice that the rules needed to be loaded to <em>iptables</em> by running <code>iptables-restore &lt; /etc/iptables.rules</code> and a file <code>/etc/network/if-pre-up.d/iptables-init</code> with <code>+x</code> permissions is required to recover <em>iptables</em> rules when the server is rebooted.</p><h3 id=automatic-updates>Automatic updates<a hidden class=anchor aria-hidden=true href=#automatic-updates>#</a></h3><p><a href=https://wiki.debian.org/UnattendedUpgrades>Unanttended upgrades</a> seemed like a handy way to keep the server up-to-date. After installing the package running <code>apt install unattended-upgrades</code> the configuration file in <code>/etc/apt/apt.conf.d/50unattended-upgrades</code> required a minor tweak as default origin was set to Debian instead of Raspbian:</p><pre tabindex=0><code>...
Unattended-Upgrade::Origins-Pattern {
    &#34;origin=Raspbian,codename=${distro_codename}
}
...
</code></pre><h3 id=disable-unneeded-services>Disable unneeded services<a hidden class=anchor aria-hidden=true href=#disable-unneeded-services>#</a></h3><p>As the Pi will be running purely as a web server, there were handful of features and services that can be just disabled. Here&rsquo;s some for starters.</p><p>Disable BlueTooth and WiFi during bootup:</p><pre tabindex=0><code>
/boot/config.txt

...

dtoverlay=pi3-disable-bt
dtoverlay=pi3-disable-wifi
</code></pre><p>Disable unneeded <em>systemd</em> services:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># disable dhcpcd</span>
</span></span><span class=line><span class=cl>systemctl disable dhcpcd.service <span class=o>&amp;&amp;</span> systemctl stop dhcpcd.service
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Bluetooth-related services</span>
</span></span><span class=line><span class=cl>systemctl disable bluealsa.service <span class=o>&amp;&amp;</span> systemctl stop bluealsa.service
</span></span><span class=line><span class=cl>systemctl disable hciuart.service <span class=o>&amp;&amp;</span> systemctl stop hciuart.service
</span></span><span class=line><span class=cl>systemctl disable bluetooth.service <span class=o>&amp;&amp;</span> systemctl stop bluetooth.service
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Avahi is an open source implementation of Bonjour/Zeroconf protocol for service discovery.</span>
</span></span><span class=line><span class=cl>systemctl disable avahi-daemon.service <span class=o>&amp;&amp;</span> systemctl stop avahi-daemon.service
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># No sound needed and also disabled in boot configured earlier</span>
</span></span><span class=line><span class=cl>systemctl disable alsa-restore.service <span class=o>&amp;&amp;</span> systemctl stop alsa-restore.service
</span></span></code></pre></div><p>There might still be unneeded services left on my RasPi, but I&rsquo;ll add them here afterwards as I find more. :-)</p><h3 id=caddy-and-hugo>Caddy and Hugo<a hidden class=anchor aria-hidden=true href=#caddy-and-hugo>#</a></h3><p><a href=https://caddyserver.com/>Caddy</a> is a HTTP/2 web server with support for automatic HTTPS using Let&rsquo;s Encrypt certificates. While it would not be tedious to set up a battle-hardened <em>nginx</em> or <em>Apache</em> using the same certificate provider, I wanted to give a shot at Caddy due to a recommendation from a friend. Besides, it&rsquo;s written in Go (yes, I am a bit biased to try new tech), which made me more curious for my use case as a personal web server.</p><p>Installing hugo is possible using <em>apt</em>, but the version was a bit outdated at the time of writing this post. As instructed in the <a href=https://github.com/gohugoio/hugo/issues/3995>Hugo Github Issue #3995</a>, it was possible to use the ARM architecture binary straight from the releases in the repository.</p><h4 id=lets-encrypt>Let&rsquo;s Encrypt<a hidden class=anchor aria-hidden=true href=#lets-encrypt>#</a></h4><p><a href=https://letsencrypt.org/>Let&rsquo;s Encrypt</a> (LE) is a certificate authority founded by <a href=https://www.eff.org/>EFF</a>, <a href=https://www.mozilla.org/en-US/foundation/>Mozilla Foundation</a> et al. whose mission is to allow easy and fast deployment of X.509 certificates. The project aims to make encrypted connections ubiquitous and being completely transparent of the certificate issuances. The approach to the issuance process is interesting, and I really recommend reading it from <a href=https://letsencrypt.org/how-it-works/>Let&rsquo;s Encrypt documentation</a>.</p><p>To sum it up, Let&rsquo;s Encrypt together with Automatic Certificate Management Environment protocol are the basis to handle requesting, creation, issuance, and validation without human intervention. Domain validation is based on a challenge that the LE server sends to the client (your server) that is requesting a certificate. By proving these challenges that you actually host the server in the domain and after the key authorization, the client is allowed to do certificate management for the domain and can request for a certificate. Caddy handles all this automatically, but it would require just two shell commands to do manually as well.</p><h4 id=configuration>Configuration<a hidden class=anchor aria-hidden=true href=#configuration>#</a></h4><p>Caddy is quite straightforward to install and configure:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># git and hugo submodules are needed: git for webhook, I hugo for compiling and deploying static website so it&#39;s optional.</span>
</span></span><span class=line><span class=cl>curl https://getcaddy.com <span class=p>|</span> bash -s http.git,http.hugo
</span></span></code></pre></div><p>Basic configuration is also quite simple and HTTP is enabled by default, which is quite beautiful. Note also that <a href=https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Strict-Transport-Security>HSTS</a> header needs to be added manually. In short, this tells web browsers to use only HTTPS to access the site. If you have subdomains, refer to the Mozilla documentation for more details.</p><pre tabindex=0><code>domain {
    root /var/www/domain
    tls [mail-address]

    header / {
        Strict-Transport-Security &#34;max-age=31536000;&#34;
    }
}
</code></pre><p>That&rsquo;s all that is needed for basic hosting of a website. Now Caddy should be run as separate user, which is commonly <code>www-data</code>, and as a daemon on the background. Caddy documentations have a nice template how this is done using <code>systemd</code> which I also ended up using. You can find the documentation for this at <a href=https://github.com/mholt/caddy/tree/master/dist/init/linux-systemd>https://github.com/mholt/caddy/tree/master/dist/init/linux-systemd</a>, which also includes instructions to set up the www-data user properly.</p><p>As in documentation, the Caddy binary needs the ability to bind to privileged ports 80 and 443. <code>cap_net_bind_service</code> <a href=http://man7.org/linux/man-pages/man7/capabilities.7.html>does exactly this</a></p><pre tabindex=0><code>setcap &#39;cap_net_bind_service=+ep&#39; /usr/local/bin/caddy
</code></pre><p>After this, I needed to check, study, edit, and deploy the <code>caddy.service</code> file accordingly and enable these parameters in the configuration.</p><pre tabindex=0><code>CapabilityBoundingSet=CAP_NET_BIND_SERVICE
AmbientCapabilities=CAP_NET_BIND_SERVICE
NoNewPrivileges=true
</code></pre><p>At least I had issues starting Caddy as a service due to that it was not able to bind to the ports 80 and 443. This ticket in Caddy Community was quite helpful: <a href=https://caddy.community/t/caddy-wont-start-could-not-start-http-server-for-challenge-listen-tcp-80-bind-permission-denied/2543/2>https://caddy.community/t/caddy-wont-start-could-not-start-http-server-for-challenge-listen-tcp-80-bind-permission-denied/2543/2</a></p><h3 id=github-webhooks>Github Webhooks<a hidden class=anchor aria-hidden=true href=#github-webhooks>#</a></h3><p>Now that the web server is running and serves the website properly, it would be nice to have something else than Hello World as content. I use Hugo as main platform for creating website content. It&rsquo;s a static website framework written - <em>surprise</em> - Go. The posts are written in Markdown which is compiled to a static website. It also has already quite a handful of themes available as well from the community.</p><p>I wanted to automate the deployment flow in a way that I could make blog posts anywhere with my devices with a text editor and publish them on my server using <em>git</em> without need to interact with the server. One way to do this are Git webhooks. So the workflow goes about like this:</p><ul><li>Blog posts are in Markdown in a <em><strong>private</strong></em> git repository (access using SSH)</li><li>Edit posts locally and push changes to git</li><li>With every push to master branch from your device, posts that are not drafted should be published</li><li>The server has a Git webhook configured that receives a notification of activity in the branch</li><li>The server pulls latest revision of the site</li><li>The server builds new version of the site and deploys it</li></ul><p>Caddy has a plugin support for Git webhooks, which was installed earlier. Now this requires couple of more lines to the configuration as well as creation of a SSH keypair for <em>www-data</em> user and activating Git webhook to the repository. Note that if your site is in a public git repository, you can also skip the key creation and configuration and use the public HTTPS URL instead.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>sudo su www-data -s /bin/bash
</span></span><span class=line><span class=cl>mkdir -p /srv/www/.ssh
</span></span><span class=line><span class=cl>chmod <span class=m>700</span> /srv/www/.ssh
</span></span><span class=line><span class=cl>ssh-keygen -t rsa -b <span class=m>4096</span> /srv/www/.ssh/github_webhook_key
</span></span><span class=line><span class=cl><span class=c1># check that permissions are 644 for the public key, 600 for the private key</span>
</span></span></code></pre></div><p>After the key creation the Caddyfile needs to be edited to use the git plugin and access the repository using the private key which we created earlier. One handy way to create a secret key is to use <code>openssl rand -base64 32</code>, but there are definitely as many ways to create it as there are developers out there in the wild.</p><pre tabindex=0><code>/etc/caddy/Caddyfile

domain {
    root /var/www/site
    tls [mail]
    
    git git@github.com:[account]/[repository].git {
        hook /webhook [SECRET_KEY]
        path /tmp/site
        key /srv/www/.ssh/github_webhook_key
        then hugo --destination=/var/www/site --cleanDestinationDir
    }

    header / {
        Strict-Transport-Security &#34;max-age=315360000;&#34;
    }
}
</code></pre><p>All these operations in the configuration are performed as www-data user using which the Caddy is running. After this, Caddy needs to be restarted: <code>systemctl restart caddy.service</code>. Now the webhook and SSH key needs to be configured to the repository in Github.com. Open up your private repository settings and select <em>&ldquo;webhooks&rdquo;</em>. Select <em>&ldquo;Add webhook&rdquo;</em> and fill up the settings:</p><ul><li><code>Payload URL</code>: <a href=https://your.site.domain/webhook>https://your.site.domain/webhook</a> (the path was configured for the webhook)</li><li><code>Content type</code>: <code>application/json</code> (Caddy seemed to require this?)</li><li><code>Secret</code>: SECRET_KEY which was inserted in the Caddyfile configuration</li><li>Select &ldquo;Just the push event&rdquo;, it&rsquo;s enough for the site updates.</li></ul><p>Read permissions are enough for this use to just update the hosted site, so the SSH key can be added to &ldquo;Deploy keys&rdquo; with read-only access. Read more at: <a href=https://developer.github.com/webhooks/creating/>Github documentation on Webhook creation</a>.</p><h2 id=auditing>Auditing<a hidden class=anchor aria-hidden=true href=#auditing>#</a></h2><p>Huzzah! Now the web server is hosting the static website. Now what? It would be also fun to check out how the server fares out in the wild, so it was fun to do even basic level auditing. While I&rsquo;m not a huge fan of &ldquo;checkbox security&rdquo;, I&rsquo;d recommend at minimum running <code>nmap</code> and also found out about <code>lynis</code> for auditing. Auditing my own servers was fun, and these tools are something to start from something.</p><h2 id=conclusions>Conclusions<a hidden class=anchor aria-hidden=true href=#conclusions>#</a></h2><p>Well, this setup was a rabbit hole after all: After starting with something, new concepts led to another and I found myself reading hours of <em>systemd</em>, <em>iptables</em>, and Debian networking internals documentations at 2 AM in the night. Also from auditing point of view, Caddy feels like an interesting fuzzing target. It uses Go&rsquo;s standard library for HTTP functionalities and the list of Caddy&rsquo;s <a href=https://en.wikipedia.org/wiki/Caddy_(web_server)#Capabilities>capabilities</a> is quite long, which might be interesting to fuzz.</p><p>I could have also set up the web server in a separate Docker container but as I won&rsquo;t be running other services (yet) on the server, it felt a bit overkill. From security point of view, also Docker containers don&rsquo;t work as 100% proof isolation from the system even if it might provide some level of isolation e.g. from privilege escalation. Might be still an interesting project to do some day and it would provide more consistent backup mechanisms to restore the server in case anything goes wrong. One improvement task would also be to deploy Cloudformation in front of the server, as the caching would also save card I/O on the Pi. Deploying SELinux as well would be an interesting project to study at some point. It would also be great to have better visibility and monitoring to server logs, and logging could be more verbose for diagnostics.</p><p>It was also interesting to notice that while using a system account feels a bit questionable for repository syncing, I did not find a way to configure Caddy to use a separate sync user to pull the Git repository.</p><h2 id=further-reading>Further reading<a hidden class=anchor aria-hidden=true href=#further-reading>#</a></h2><p><a href=https://www.freedesktop.org/wiki/Software/systemd/PredictableNetworkInterfaceNames/>Freedesktop.org: Predictable Network Interface Names</a></p><p><a href=https://wiki.debian.org/NetworkConfiguration#Predictable_Network_Interface_Names>Debian: Network Configuration</a></p><p><a href=https://wiki.debian.org/UnattendedUpgrades>Debian: Unattended Upgrades</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://kraashen.github.io/tags/raspberrypi/>Raspberrypi</a></li><li><a href=https://kraashen.github.io/tags/tweaking/>Tweaking</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://kraashen.github.io/>tracing bytes</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>