<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Homelab on the go with Tailscale | tracing bytes</title>
<meta name=keywords content="network,tailscale"><meta name=description content="Having a home lab and services such as PiHole, RSS reader, K3s, Home Assistant, and more is fun and all at home, but how to access them when leaving the house without opening up parts of the home network to the Internet? In this post, we&rsquo;ll go through a setup of Tailscale VPN and running services such as PiHole on Debian server."><meta name=author content><link rel=canonical href=https://kraashen.github.io/posts/2024-07-26-homelab-on-the-go-with-tailscale/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://kraashen.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://kraashen.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://kraashen.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://kraashen.github.io/apple-touch-icon.png><link rel=mask-icon href=https://kraashen.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://kraashen.github.io/posts/2024-07-26-homelab-on-the-go-with-tailscale/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Homelab on the go with Tailscale"><meta property="og:description" content="Having a home lab and services such as PiHole, RSS reader, K3s, Home Assistant, and more is fun and all at home, but how to access them when leaving the house without opening up parts of the home network to the Internet? In this post, we&rsquo;ll go through a setup of Tailscale VPN and running services such as PiHole on Debian server."><meta property="og:type" content="article"><meta property="og:url" content="https://kraashen.github.io/posts/2024-07-26-homelab-on-the-go-with-tailscale/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-07-26T00:00:00+00:00"><meta property="article:modified_time" content="2024-07-26T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Homelab on the go with Tailscale"><meta name=twitter:description content="Having a home lab and services such as PiHole, RSS reader, K3s, Home Assistant, and more is fun and all at home, but how to access them when leaving the house without opening up parts of the home network to the Internet? In this post, we&rsquo;ll go through a setup of Tailscale VPN and running services such as PiHole on Debian server."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://kraashen.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Homelab on the go with Tailscale","item":"https://kraashen.github.io/posts/2024-07-26-homelab-on-the-go-with-tailscale/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Homelab on the go with Tailscale","name":"Homelab on the go with Tailscale","description":"Having a home lab and services such as PiHole, RSS reader, K3s, Home Assistant, and more is fun and all at home, but how to access them when leaving the house without opening up parts of the home network to the Internet? In this post, we\u0026rsquo;ll go through a setup of Tailscale VPN and running services such as PiHole on Debian server.","keywords":["network","tailscale"],"articleBody":"Home Lab on the Go with Tailscale Introduction Having a home lab and services such as PiHole, RSS reader, K3s, Home Assistant, and more is fun and all at home, but how to access them when leaving the house without opening up parts of the home network to the Internet?\nOne option is to use a VPN service to access them, but they can be bunch of work to set up on your own. Luckily there is a ready solution called Tailscale which:\ndoesn’t take too much time to set up has native client applications for Linux servers, Linux laptop, and iOS/Android is free for private small-scale use (though always consider to support a great project!) is easy to maintain and operate And lastly an exciting feature that was added to the Tailscale iOS app some time back that helps with having everything on-the-go: It can be configured to turn on automatically when leaving a WiFi network.\nNote here that you will need an account to a domain registrar and an existing domain with an ownership to manage and create API tokens and A/AAAA records for this post.\nIn this post, we’ll go through a setup of running following on Debian server:\nLet’s Encrypt for TLS certificates for all hosted subdomains PiHole for ad blocking (it’s nice to browse the Internet without clutter on the go as well) Tailscale Tailscale is an easy-to-use zero-config VPN that can be used to quickly set up private networks. It is based zero trust networking principle and uses an approach where each device and service is encapsulated individually (practically meaning WireGuard and device-only local private keys), and each session between devices in the network is end-to-end encrypted.\n“Zero-config” in practice, means basically that all you need is:\nTailscale account (created using only a third party OIDC service such as Google/Apple ID or such) Tailscale app on mobile Running Tailscale binary on your server and with these, a basic functional hybrid-meshing VPN network is ready to go. Depending on personal or company requirements, naturally more configuration might be required.\nFurthermore, if there is need for more fine-grained networking, the configuration options include ACLs, custom service integrations, custom DNS routing, and much more. One cool feature is also a solution to share files directly between Tailscale clients! Personal AirDrop’ish!\nHow does it work? Tailscale is developed in Golang and is based on WireGuard VPN. Albeit being used synonymously as a VPN solution, WireGuard is a FOSS communication protocol to implement encrypted VPNs which passes network traffic on UDP. One major implementation of it has been included in the Linux Kernel 5.6 in 2020. It aims for simplicity, extendability, and faster transfers compared to earlier solutions such as OpenVPN or IPsec tunneling.\nBuilding on top of WireGuard, Tailscale provides both developer and user-friendly features such as single sing-on (SSO), TCP transport (with DERP), NAT traversal, and ACLs (with programmatic APIs!), and much more. On top of this, it leverages integrations to various services, such as databases, firewalls, web servers, NAS’es, and other remote use case services.\nGoing through all the features might be an overshoot for a home lab, though some of them might be interesting to try out at some point such as integration with Caddy (or Traefik when running K3s), remote VSCode, and NAS servers.\nHow does Tailscale do the magic for the homelab network available for other devices outside the house?\nThere is an extensive blog post about how it works here, but let’s go through the concepts on a high level.\nTailnet A Tailscale network, “Tailnet”, consists of a data plane and a control plane. The data plane is a collection of nodes/machines running a Tailscale client. The control plane consists of the coordinator and for instance, the auth server. Control plane manages the metadata exchange and maintenance between peers, in which resides the Coordinator - service maintained by Tailscale.\nCoordinator A coordination server is a service in a Tailnet that distributes the public keys and settings to the clients in the private networks, referred to as “Tailnets”.\nWhen a new client is started the first time, new pair of private and public keys are generated, and the public key with the Tailscale controller is exchanged, and the client is added to your Tailnet.\nThe control plane works in hub-and-spoke manner, but does not carry the traffic that the clients discuss between each other. It plainly assists the clients to exchange encryption keys and the domain policies. It works as a hybrid solution in between traditional VPN hub-and-spoke model and mesh model.\nNow that the clients know about each others’ whereabouts and have a hold on their public keys, how do these communicate from behind a NATted home network?\nNAT traversal magic and DERP Tailscale implements seceral techniques to allow nodes to find each other online and establish peer-to-peer connections. These techniques are based on STUN and ICE standards, and handful of NAT traversal hoops and algorithms. Tailscale has a great technical article explaining this. Tailscale implements handful of interesting techniques to bypass this, and the article is a highly recommended read for anyone interested in networking. (I was astounded when reading their documentation about these NAT magics, it was pretty cool! Without spoiling too much, the birthday attack really got me.) It works as a fallback in case direct connection fails.\nIn practice, all these together nicely avoid the need for any custom complex firewall configurations, NAT magic, or opening ports - and it just works.\nIn some harder networks where direct connection between nodes is hard or impossible, the clients pass the connection through using Designated Encrypted Relay Protocol (DERP).\nDERP is Tailscale’s implementation that uses HTTPS streams and WireGuard for communication. These relay proxies act as an intermediaries to pass traffic between clients for example in networks where outbound UDP is blocked by default.\nAs the traffic is encrypted between peers, the relays cannot see what’s up between the clients. After they successfully initiate direct connection between each other, the connection changes to mesh networking.\nNow the clients are discussing and everything is great. Altough as a curiosity, if I want to share a service with friends or I need to convince my corporate IT, how can I restrict access in my Tailnet? How do the access controls work? How can services and nodes be restricted between users and user groups?\nVPNs provide mechanisms for restricting traffic between clients using stuff like firewalls and VPN identity systems, but in a role-based world (I’m looking at you IAM and it’s derivatives), Tailscale implements cool feature: Programmatic ACLs!\nACLs Remember how Tailscale works as a peer-to-peer meshed VPN? The firewall rules need to be somewhere, and if control server does not know them anymore after sending them back to the client, where are they?\nAnswer is: In each client!\nEach node handles blocking and allowing incoming and outgoing connections based on the configured ACLs. Also, each node is given the public keys only of the nodes they are allowed to connect to. This way, each node also on its own acts both as a firewall to the network and a client who communicates there.\nThese can be configured granularly for users, groups, tags (yes, things can be tagged as well based on use cases), services, posture rules, and nodes. The syntax is JSON based, has support for testing changes before applying rules - and has native GitOps integrations as well! Hooray for CI automations!\nSetting up Now, let’s go through how to set this thing up in a home network and servers!\nServer Run the installation script provided in Tailscale web page\nAnd run the binary\n# tailscale up You will be provided an authentication link in your terminal, after which your Tailscale client is associated with your user account, the private and public keys are generated, and the public key with the Tailscale controller is exchanged, and the client is added to your Tailnet.\nAnd that’s it!\nLet’s still go through some nitty details about the networking for few services, especially PiHole on-the-go.\nAfter setting up your mobile app and connecting it to your Tailnet, you should be able to see your server listed in the list of connected machines.\nMobile This is pretty much the grain and salt for the automatic deployment: turning Tailscale on-demand when on cellular network but disabled when on WiFi!\nAfter installing the Tailscale app and logging in:\nGo to Settings VPN On-Demand Enable VPN On-Demand Set Wi-Fi -\u003e Never Set Cellular -\u003e Always Optionally if you like, enable detecting MagicDNS hostnames Obvious caveat for this of course is, that when connecting other WiFi’s, the VPN will be disabled. However limiting the use case now for home lab and private use, I think this is sufficient to manage personally.\nDNS By default, the machines can be referred to and accessed using their Tailnet IP addresses and hostnames. Tailscale provides multiple ways of referring to host’s addresses:\nUsing “Magic DNS”, which is Tailscale feature of auto-assigning the hostname of the machine as the connectable DNS name. This simply means that hostname lab-1 machine can be accessed e.g. by: ssh lab-1 on your account. How this works is that underneath, Tailscale generates an FQDN for the hostname, which is a combination of the hostname and a Tailnet suffix. For example, this means that lab-kubernetes-1 hostname and a Tailnet name foobar.ts.net full FQDN is lab-kubernetes-1.foobar.ts.net. This is then added to the Search Domain of your Tailnet, which is used for processing incoming DNS requests within the Tailnet. Tailnet is always the first search domain. In case you are accessing a machine shared to you, full FQDN is required, but in this case we’ll be looking into private homelab for personal uses. This feature is nowadays enabled by default for all new accounts.\nUsing custom DNS settings in the Tailscale Admin console. These settings can be used to enable/disable the MagicDNS, and adding alternative nameservers and their configurations. One setting we will be looking into is Split DNS with PiHole.\nUsing public DNS records. This allows using either using custom self-managed DNS servers or public DNS resolvers in the nameserver settings.\nServices In this section, lets go through some use cases and services that can be used with Tailscale while going around town and traveling.\nTLS Certificates with Let’s Encrypt Let’s Encrypt is an open certificate authority (CA) which provides easy automation, provision and renewal of TLS certificates. Personally I have enjoyed using Certbot for managing TLS certificates, but there are handful of options as well to choose from.\nExplanation and use of Let’s Encrypt certificates with DNS-01 challenge and Certbot could be a whole separate topic itself, so here matter won’t be discussed so much. Let’s go through the crude installation and setup process. This section will presume having an existing registered domain and a supported registrar from the Certbot’s list of DNS providers.\nInstall certbot\nsudo apt install certbot Get the necessary API token / credential / config for your domain registrar and configure it\nmkdir -m 0755 -p /etc/letsencrypt/ nvim /etc/letsencrypt// chmod 0700 /etc/letsencrypt// I’m using Caddy with a Certbot renewal hook which rotates the updated certificates, but there are other options here to choose as well.\nAfter configuring, new certificates can be requested with:\ncertbot certonly \\ --authenticator dns- \\ --dns--credentials /etc/letsencrypt// \\ -d subdomain.foobar.com \\ -d more.foobar.com \\ --deploy-hook /etc/letsencrypt/renewal-hooks/deploy/00-caddy.sh after this, certificates are issued and later renewed as well! (Certbot will maintain these running as a Systemd unit in the background.)\nPiHole Now that the certificate part is taken care of, let’s dive into “How can I browse the Internet without the clutter and ads on-the-go?” Yes, browser level blockers can be used and I also use both of them. Personally, I feel both of them nicely complement each other!\nSetting up PiHole can be done with their official instructions with the desired setup method.\nWhen that is done, the local firewall (using ufw) needs to accept DNS requests in tailscale interface: (IP address pool for Tailscale if not too restrictive)\n# just an example subnet and \"to any\" definition, feel free to adjust ufw allow in on tailscale0 from 100.64.0.0/10 to any port 53 proto tcp ufw allow in on tailscale0 from 100.64.0.0/10 to any port 53 proto udp …and also the rest of the ports provided in the Tailscale documentation.\nufw allow in on tailscale0 from 100.64.0.0/10 to any port 443 proto tcp ufw allow in on tailscale0 from 100.64.0.0/10 to any port 41641 proto udp …and rerun Tailscale with --accept-dns=false flag to avoid PiHole using itself as a resolver.\ntailscale up --accept-dns=false Tailscale also has a neat documentation explaining the rest of the steps, but in short summary:\nDisable the Tailnet key expiry for the server unless you want to maintain the key monthly Set Raspberry Pi as the main DNS server in Tailscale DNS settings Set override local as Enabled Go to PiHole Admin page -\u003e Settings -\u003e DNS -\u003e Listen on all interfaces, permit all origins Otherwise, PiHole won’t be accepting DNS requests from the Tailnet clients. Make sure that your network is firewalled properly behind a router so that the PiHole does not publish itself to the world. And that’s pretty much it! Before going wild, there’s still one more thing to do in this kind of setup where TLS certificates are public for internal addresses: Split DNS!\nSplit DNS Split DNS is a Tailscale feature for splitting DNS requests sent to different resolvers based on their domain name.\nFor example, if you want to send out certain requests about *.barfoo.ly to another DNS server and leave rest to the Tailscale to manage, you set up a Split DNS with the given domain suffix and point them to your desired resolver provider.\nIn this case, the implementation is made using LE certificates - a public cert - and a domain name with an internal IP address. So how can the devices find the Tailnet IP address for your domains if the PiHole would be returning the local IP address set at your home and not Tailnet IP address?\nIn other words, the server’s Tailnet IP address (in the range 100.0.0.0/8) is added to the domain registrar’s records. This will be an A record with the domain you created the certificate for and the IP address as the value for it. Otherwise your devices try to find your server’s IP address based on the Tailnet’s configurations - the PiHole server, effectively returning the private IP address whatever you have at home, so Tailnet clients cannot find the server. It may depend on your personal risk model if internal IPs are okay to publish on public resolvers.\nThings to do in the Tailscale Admin panel DNS settings:\nAdd a new nameserver and choose the desired provider Hit the ... on the menu item -\u003e Edit Enable “Restrict to domain” Set the private domain you have ownership to as the restricted domain Changes propagate quite fast with Tailscale to the mobile app, so you should be able to connect to cellular network and try it out!\nIf the solution does not yet work, check if your newly added A records in your domain registrar’s system have been added to the public resolvers you configured earlier:\ndig whatever.foobar.com @1.1.1.1 # using the public resolver you added in the previous steps Other services At this point, a working home lab on-the-go should be up and running! All the services running on your host with domain names should work when you have TLS certificates in place, A records configured to point to your home server, and the reverse proxies for the services running on the host(s).\nThese could be anything you do labbing with such as:\nHome Assistant - bring your home automation with you. RSS Reader - read news with the reader you use at home (Miniflux is pretty nice and simple). Photo gallery - Photoprism is a cool project! NFS - Personal data store in the pocket. Summary In this post, a setup with Tailscale VPN and home lab connectivity was explored. Tailscale provides a way to automatically turn on VPN when leaving the house, so you’ll always have your lab services with you. Tailscale provides handful of native integrations for web servers and NFS, but these were not discussed this time.\nAlternative options to implement this could include using .lan or similar convention for local addresses and Tailnet machine names and addresses separately. This way, no domain registrar would be needed. In this case however, if TLS is a needed feature, a separate CA needs to be created and added to each Tailnet device’s trust store to avoid nagging about self-signed certificates.\nAlso, many Tailscale features like programmatic APIs, sharing services with friends, more granular ACL controls, and such were not explored this time. Also, setting up the LE certificates with auto renewal e.g. for Caddy or Nginx is a separate adventure of its own.\nWhat are you running at home that you like to have also with you on-the-go?\nReferences Tailscale - Why Tailscale? Tailscale Docs - Zero Trust Tailscale Docs - Wireguard Comparison Certbot Docs Wireguard - Wikipedia Tailscale - IP Address Pool ","wordCount":"2864","inLanguage":"en","datePublished":"2024-07-26T00:00:00Z","dateModified":"2024-07-26T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://kraashen.github.io/posts/2024-07-26-homelab-on-the-go-with-tailscale/"},"publisher":{"@type":"Organization","name":"tracing bytes","logo":{"@type":"ImageObject","url":"https://kraashen.github.io/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://kraashen.github.io/ accesskey=h title="tracing bytes (Alt + H)">tracing bytes</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://kraashen.github.io/ title=Home><span>Home</span></a></li><li><a href=https://kraashen.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://kraashen.github.io/snippets/ title=Snippets><span>Snippets</span></a></li><li><a href=https://kraashen.github.io/my-library/ title="My Library"><span>My Library</span></a></li><li><a href=https://kraashen.github.io/interests/ title=Interests><span>Interests</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Homelab on the go with Tailscale</h1><div class=post-meta><span title='2024-07-26 00:00:00 +0000 UTC'>July 26, 2024</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#home-lab-on-the-go-with-tailscale aria-label="Home Lab on the Go with Tailscale">Home Lab on the Go with Tailscale</a><ul><li><a href=#introduction aria-label=Introduction>Introduction</a></li><li><a href=#tailscale aria-label=Tailscale>Tailscale</a><ul><li><a href=#how-does-it-work aria-label="How does it work?">How does it work?</a><ul><li><a href=#tailnet aria-label=Tailnet>Tailnet</a></li><li><a href=#coordinator aria-label=Coordinator>Coordinator</a></li><li><a href=#nat-traversal-magic-and-derp aria-label="NAT traversal magic and DERP">NAT traversal magic and DERP</a></li><li><a href=#acls aria-label=ACLs>ACLs</a></li></ul></li><li><a href=#setting-up aria-label="Setting up">Setting up</a><ul><li><a href=#server aria-label=Server>Server</a></li><li><a href=#mobile aria-label=Mobile>Mobile</a></li></ul></li><li><a href=#dns aria-label=DNS>DNS</a></li></ul></li><li><a href=#services aria-label=Services>Services</a><ul><li><a href=#tls-certificates-with-lets-encrypt aria-label="TLS Certificates with Let&rsquo;s Encrypt">TLS Certificates with Let&rsquo;s Encrypt</a></li><li><a href=#pihole aria-label=PiHole>PiHole</a><ul><li><a href=#split-dns aria-label="Split DNS">Split DNS</a></li></ul></li><li><a href=#other-services aria-label="Other services">Other services</a></li></ul></li><li><a href=#summary aria-label=Summary>Summary</a></li><li><a href=#references aria-label=References>References</a></li></ul></li></ul></div></details></div><div class=post-content><h1 id=home-lab-on-the-go-with-tailscale>Home Lab on the Go with Tailscale<a hidden class=anchor aria-hidden=true href=#home-lab-on-the-go-with-tailscale>#</a></h1><h2 id=introduction>Introduction<a hidden class=anchor aria-hidden=true href=#introduction>#</a></h2><p>Having a home lab and services such as PiHole, RSS reader, K3s, Home Assistant, and
more is fun and all at home, but how to access them when leaving the house
without opening up parts of the home network to the Internet?</p><p>One option is to use a VPN service to access them, but they can be bunch of work
to set up on your own. Luckily there is a ready solution called Tailscale which:</p><ul><li>doesn&rsquo;t take too much time to set up</li><li>has native client applications for Linux servers, Linux laptop, and iOS/Android</li><li>is free for private small-scale use (though always consider to support a great project!)</li><li>is easy to maintain and operate</li></ul><p>And lastly an exciting feature that was added to the Tailscale iOS app some time back that helps
with having everything on-the-go: <strong>It can be configured to turn on automatically</strong>
<strong>when leaving a WiFi network.</strong></p><p>Note here that you will need an account to a domain registrar and an existing domain
with an ownership to manage and create API tokens and A/AAAA records for this post.</p><p>In this post, we&rsquo;ll go through a setup of running following on Debian server:</p><ul><li>Let&rsquo;s Encrypt for TLS certificates for all hosted subdomains</li><li>PiHole for ad blocking (it&rsquo;s nice to browse the Internet without clutter on the go as well)</li></ul><h2 id=tailscale>Tailscale<a hidden class=anchor aria-hidden=true href=#tailscale>#</a></h2><p><a href=https://tailscale.com/>Tailscale</a> is an easy-to-use zero-config VPN that can be
used to quickly set up private networks. It is based zero trust networking principle
and uses an approach where each device and service is encapsulated individually
(practically meaning WireGuard and device-only local private keys), and each session
between devices in the network is end-to-end encrypted.</p><p>&ldquo;Zero-config&rdquo; in practice, means basically that all you need is:</p><ul><li>Tailscale account (created using only a third party OIDC service such as Google/Apple ID or such)</li><li>Tailscale app on mobile</li><li>Running Tailscale binary on your server</li></ul><p>and with these, a basic functional hybrid-meshing VPN network is ready to go. Depending on personal or
company requirements, naturally more configuration might be required.</p><p>Furthermore, if there is need for more fine-grained networking, the configuration options
include ACLs, custom service integrations, custom DNS routing, and much more.
One cool feature is also a solution to share files directly between Tailscale clients!
Personal AirDrop&rsquo;ish!</p><h3 id=how-does-it-work>How does it work?<a hidden class=anchor aria-hidden=true href=#how-does-it-work>#</a></h3><p>Tailscale is developed in Golang and is based on WireGuard VPN.
Albeit being used synonymously as a VPN solution, WireGuard is a FOSS communication protocol
to implement encrypted VPNs which passes network traffic on UDP. One major implementation of it
has been <a href=https://www.wireguard.com/papers/wireguard.pdf>included in the Linux Kernel 5.6 in 2020</a>.
It aims for simplicity, extendability, and faster transfers compared to earlier solutions
such as OpenVPN or IPsec tunneling.</p><p>Building on top of WireGuard, Tailscale provides both developer and user-friendly features such as
<a href=https://tailscale.com/kb/1035/wireguard>single sing-on (SSO), TCP transport (with DERP), NAT traversal, and ACLs (with programmatic APIs!)</a>,
and much more. On top of this, it leverages integrations to various services, such as databases,
firewalls, web servers, NAS&rsquo;es, and other remote use case services.</p><p>Going through all the features might be an overshoot for a home lab, though some of them might be interesting
to try out at some point such as <a href=https://tailscale.com/kb/1190/caddy-certificates>integration with Caddy</a>
(or <a href=https://tailscale.com/kb/1234/traefik-certificates>Traefik</a> when running K3s),
<a href=https://tailscale.com/kb/1265/vscode-extension>remote VSCode</a>,
and <a href=https://tailscale.com/kb/1307/nas>NAS</a> servers.</p><p>How does Tailscale do the magic for the homelab network available for other devices outside the house?</p><p>There is an extensive blog post about how it works <a href=https://tailscale.com/blog/how-tailscale-works>here</a>,
but let&rsquo;s go through the concepts on a high level.</p><h4 id=tailnet>Tailnet<a hidden class=anchor aria-hidden=true href=#tailnet>#</a></h4><p>A Tailscale network, &ldquo;Tailnet&rdquo;, consists of a data plane and a control plane. The data plane
is a collection of nodes/machines running a Tailscale client. The control plane consists of
the coordinator and for instance, the auth server. Control plane manages the metadata exchange
and maintenance between peers, in which resides the Coordinator - service maintained by Tailscale.</p><p><img loading=lazy src=/img/tailscale-homelab-topology.png alt></p><h4 id=coordinator>Coordinator<a hidden class=anchor aria-hidden=true href=#coordinator>#</a></h4><p>A coordination server is a service in a Tailnet that distributes the
public keys and settings to the clients in the private networks, referred to as &ldquo;Tailnets&rdquo;.</p><p>When a new client is started the first time, new pair of private and public keys
are generated, and the public key with the Tailscale
controller is exchanged, and the client is added to your Tailnet.</p><p><img loading=lazy src=/img/tailscale-client-join-flow.png alt></p><p>The control plane works in hub-and-spoke manner, but does not carry the traffic that the clients discuss
between each other. It plainly assists the clients to exchange encryption keys and the domain policies.
It works as a hybrid solution in between traditional VPN hub-and-spoke model and
mesh model.</p><p>Now that the clients know about each others&rsquo; whereabouts and have a hold on their public keys,
how do these communicate from behind a NATted home network?</p><h4 id=nat-traversal-magic-and-derp>NAT traversal magic and DERP<a hidden class=anchor aria-hidden=true href=#nat-traversal-magic-and-derp>#</a></h4><p>Tailscale implements seceral techniques to allow nodes to find each other online and establish
peer-to-peer connections. These techniques are based on STUN and ICE standards, and handful of
NAT traversal hoops and algorithms. <a href=https://tailscale.com/blog/how-nat-traversal-works>Tailscale has a great technical article explaining this</a>. Tailscale implements handful of interesting techniques to bypass this, and the article is
a highly recommended read for anyone interested in networking. (I was astounded when reading their documentation
about these NAT magics, it was pretty cool! Without spoiling too much, the birthday attack really got me.)
It works as a fallback in case direct connection fails.</p><p>In practice, all these together nicely avoid the need for any custom complex firewall configurations,
NAT magic, or opening ports - <strong>and it just works</strong>.</p><p>In some harder networks where direct connection between nodes is hard or impossible,
the clients pass the connection through using Designated Encrypted Relay Protocol (DERP).</p><p><img loading=lazy src=/img/tailscale-derp-init.png alt></p><p>DERP is Tailscale&rsquo;s implementation that uses HTTPS streams and WireGuard
for communication. These relay proxies act as an intermediaries to pass traffic between clients
for example in networks where outbound UDP is blocked by default.</p><p><img loading=lazy src=/img/tailscale-derp-after.png alt></p><p>As the traffic is encrypted between peers, the relays cannot see what&rsquo;s up between the clients. After
they successfully initiate direct connection between each other, the connection changes
to mesh networking.</p><p>Now the clients are discussing and everything is great. Altough as a curiosity, if I want to share
a service with friends or I need to convince my corporate IT, how can I restrict access in my Tailnet?
How do the access controls work? How can services and nodes be restricted between users and user groups?</p><p>VPNs provide mechanisms for restricting traffic between clients using stuff like firewalls and
VPN identity systems, but in a role-based world
(I&rsquo;m looking at you IAM and it&rsquo;s derivatives), Tailscale implements cool feature: Programmatic ACLs!</p><h4 id=acls>ACLs<a hidden class=anchor aria-hidden=true href=#acls>#</a></h4><p>Remember how Tailscale works as a peer-to-peer meshed VPN? The firewall rules need to be
somewhere, and if control server does not know them anymore after sending them back to the client,
where are they?</p><p>Answer is: In each client!</p><p>Each node handles blocking and allowing incoming and outgoing connections based on the configured
ACLs. Also, each node is given the public keys only of the nodes they are allowed to connect to.
This way, each node also on its own acts both as a firewall to the network and a client who communicates there.</p><p><img loading=lazy src=/img/tailscale-acl-firewalls.png alt></p><p>These can be configured granularly for users, groups, tags (yes, things can be tagged as well based
on use cases), services, posture rules, and nodes. The syntax is JSON based, has support for testing
changes before applying rules - and has native GitOps integrations as well! Hooray for CI automations!</p><h3 id=setting-up>Setting up<a hidden class=anchor aria-hidden=true href=#setting-up>#</a></h3><p>Now, let&rsquo;s go through how to set this thing up in a home network and servers!</p><h4 id=server>Server<a hidden class=anchor aria-hidden=true href=#server>#</a></h4><p>Run the installation script provided in <a href=https://tailscale.com/download/linux>Tailscale web page</a></p><p>And run the binary</p><pre tabindex=0><code># tailscale up
</code></pre><p>You will be provided an authentication link in your terminal,
after which your Tailscale client is associated with your user account,
the private and public keys are generated, and the public key with the Tailscale
controller is exchanged, and the client is added to your Tailnet.</p><p>And that&rsquo;s it!</p><p>Let&rsquo;s still go through some nitty details about the networking
for few services, especially PiHole on-the-go.</p><p>After setting up your mobile app and connecting it to your Tailnet, you should be
able to see your server listed in the list of connected machines.</p><h4 id=mobile>Mobile<a hidden class=anchor aria-hidden=true href=#mobile>#</a></h4><p>This is pretty much the grain and salt for the automatic deployment:
turning Tailscale on-demand when on cellular network but disabled when on WiFi!</p><p>After installing the Tailscale app and logging in:</p><ul><li>Go to Settings</li><li>VPN On-Demand</li><li>Enable VPN On-Demand<ul><li>Set Wi-Fi -> Never</li><li>Set Cellular -> Always</li><li>Optionally if you like, enable detecting MagicDNS hostnames</li></ul></li></ul><p><img loading=lazy src=/img/tailscale-mobile-on-demand.png alt></p><p>Obvious caveat for this of course is, that when connecting other WiFi&rsquo;s, the
VPN will be disabled. However limiting the use case now for home lab and
private use, I think this is sufficient to manage personally.</p><h3 id=dns>DNS<a hidden class=anchor aria-hidden=true href=#dns>#</a></h3><p>By default, the machines can be referred to and accessed using their Tailnet IP
addresses and hostnames.
<a href=https://tailscale.com/kb/1054/dns>Tailscale provides multiple ways of referring to host&rsquo;s addresses</a>:</p><ol><li><p>Using &ldquo;Magic DNS&rdquo;, which is Tailscale feature of auto-assigning the hostname
of the machine as the connectable DNS name. This simply means that hostname
<code>lab-1</code> machine can be accessed e.g. by: <code>ssh lab-1</code> on your account.
How this works is that underneath, Tailscale generates an FQDN for the hostname,
which is a combination of the hostname and a Tailnet suffix. For example,
this means that <code>lab-kubernetes-1</code> hostname and a Tailnet name <code>foobar.ts.net</code>
full FQDN is <code>lab-kubernetes-1.foobar.ts.net</code>. This is then added to the
Search Domain of your Tailnet, which is used for processing incoming DNS
requests within the Tailnet. Tailnet is <strong>always</strong> the first search domain.
In case you are accessing a machine shared
to you, full FQDN is required, but in this case we&rsquo;ll be looking into private
homelab for personal uses. This feature is nowadays enabled by
default for all new accounts.</p></li><li><p>Using custom DNS settings in the Tailscale Admin console. These settings
can be used to enable/disable the MagicDNS, and adding alternative
nameservers and their configurations. One setting we will be looking into is
<code>Split DNS</code> with PiHole.</p></li><li><p>Using public DNS records. This allows using either using custom self-managed
DNS servers or public DNS resolvers in the nameserver settings.</p></li></ol><h2 id=services>Services<a hidden class=anchor aria-hidden=true href=#services>#</a></h2><p>In this section, lets go through some use cases and services that can
be used with Tailscale while going around town and traveling.</p><h3 id=tls-certificates-with-lets-encrypt>TLS Certificates with Let&rsquo;s Encrypt<a hidden class=anchor aria-hidden=true href=#tls-certificates-with-lets-encrypt>#</a></h3><p>Let&rsquo;s Encrypt is an open certificate authority (CA) which provides easy
automation, provision and renewal of TLS certificates. Personally I have enjoyed
using Certbot for managing TLS certificates, but there are handful of options as well
to choose from.</p><p>Explanation and use of Let&rsquo;s Encrypt certificates with
<a href=https://letsencrypt.org/docs/challenge-types/#dns-01-challenge>DNS-01 challenge</a> and Certbot could be a
whole separate topic itself, so here matter won&rsquo;t be discussed so much.
Let&rsquo;s go through the crude installation and setup process. This section will presume
having an existing registered domain and a
<a href=https://eff-certbot.readthedocs.io/en/stable/using.html#dns-plugins>supported registrar from the Certbot&rsquo;s list of DNS providers</a>.</p><p>Install certbot</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>sudo apt install certbot
</span></span></code></pre></div><p>Get the necessary API token / credential / config for your domain registrar and configure it</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>mkdir -m <span class=m>0755</span> -p /etc/letsencrypt/&lt;provider&gt;
</span></span><span class=line><span class=cl>nvim /etc/letsencrypt/&lt;provider&gt;/&lt;config-file&gt;
</span></span><span class=line><span class=cl>chmod <span class=m>0700</span> /etc/letsencrypt/&lt;provider&gt;/&lt;config-file&gt;
</span></span></code></pre></div><p>I&rsquo;m using Caddy with a Certbot renewal hook which rotates the updated certificates, but
there are other options here to choose as well.</p><p>After configuring, new certificates can be requested with:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>certbot certonly <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    --authenticator dns-&lt;provider&gt; <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    --dns-&lt;provider&gt;-credentials /etc/letsencrypt/&lt;provider&gt;/&lt;config-file&gt; <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    -d subdomain.foobar.com <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    -d more.foobar.com <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    --deploy-hook /etc/letsencrypt/renewal-hooks/deploy/00-caddy.sh
</span></span></code></pre></div><p>after this, certificates are issued and later renewed as well! (Certbot will maintain these
running as a Systemd unit in the background.)</p><h3 id=pihole>PiHole<a hidden class=anchor aria-hidden=true href=#pihole>#</a></h3><p>Now that the certificate part is taken care of, let&rsquo;s dive into &ldquo;How can I browse the
Internet without the clutter and ads on-the-go?&rdquo; Yes, browser level blockers can be used
and I also use both of them. Personally, I feel both of them nicely complement each other!</p><p>Setting up PiHole can be done with their
<a href=https://docs.pi-hole.net/main/basic-install/>official instructions</a> with the desired setup method.</p><p>When that is done, the local firewall (using <code>ufw</code>) needs to accept DNS requests in tailscale interface:
(<a href=https://tailscale.com/kb/1304/ip-pool>IP address pool for Tailscale if not too restrictive</a>)</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># just an example subnet and &#34;to any&#34; definition, feel free to adjust</span>
</span></span><span class=line><span class=cl>ufw allow in on tailscale0 from 100.64.0.0/10 to any port <span class=m>53</span> proto tcp
</span></span><span class=line><span class=cl>ufw allow in on tailscale0 from 100.64.0.0/10 to any port <span class=m>53</span> proto udp
</span></span></code></pre></div><p>&mldr;and also the <a href=https://tailscale.com/kb/1082/firewall-ports>rest of the ports provided in the Tailscale documentation</a>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>ufw allow in on tailscale0 from 100.64.0.0/10 to any port <span class=m>443</span> proto tcp
</span></span><span class=line><span class=cl>ufw allow in on tailscale0 from 100.64.0.0/10 to any port <span class=m>41641</span> proto udp
</span></span></code></pre></div><p>&mldr;and rerun Tailscale with <code>--accept-dns=false</code> flag to avoid PiHole using itself as a resolver.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>tailscale up --accept-dns<span class=o>=</span><span class=nb>false</span>
</span></span></code></pre></div><p>Tailscale also has a neat <a href=https://tailscale.com/kb/1114/pi-hole>documentation</a> explaining
the rest of the steps, but in short summary:</p><ul><li>Disable the Tailnet key expiry for the server unless you want to maintain the key monthly</li><li><a href=https://tailscale.com/kb/1114/pi-hole#step-3-set-your-raspberry-pi-as-your-dns-server>Set Raspberry Pi as the main DNS server in Tailscale DNS settings</a></li><li>Set override local as <code>Enabled</code></li><li>Go to PiHole Admin page <strong>-></strong> Settings <strong>-></strong> DNS <strong>-> Listen on all interfaces, permit all origins</strong><ul><li>Otherwise, PiHole won&rsquo;t be accepting DNS requests from the Tailnet clients.</li><li>Make sure that your network is firewalled properly behind a router so that the PiHole does not publish itself to the world.</li></ul></li></ul><p>And that&rsquo;s pretty much it! Before going wild, there&rsquo;s still one more thing to do in this
kind of setup where TLS certificates are public for internal addresses: Split DNS!</p><h4 id=split-dns>Split DNS<a hidden class=anchor aria-hidden=true href=#split-dns>#</a></h4><p>Split DNS is a Tailscale feature for splitting DNS requests sent to different resolvers
based on their domain name.</p><p>For example, if you want to send out certain requests about <code>*.barfoo.ly</code> to another DNS server
and leave rest to the Tailscale to manage, you set up a Split DNS with the given domain suffix and
point them to your desired resolver provider.</p><p>In this case, the implementation is made using LE certificates - a public cert - and a
domain name with <em>an internal IP address</em>. So how can the devices find the Tailnet IP address
for your domains if the PiHole would be returning the local IP address set at your home and not
Tailnet IP address?</p><p>In other words, the server&rsquo;s Tailnet IP address (in the range 100.0.0.0/8) is added to the
domain registrar&rsquo;s records. This will be an A record with the domain you created the certificate
for and the IP address as the value for it. Otherwise your devices try to find your
server&rsquo;s IP address based on the Tailnet&rsquo;s configurations - the PiHole server, effectively
returning the private IP address whatever you have at home, so Tailnet clients cannot
find the server. It may depend on your personal risk model if internal IPs are okay to publish on
public resolvers.</p><p>Things to do in the Tailscale Admin panel DNS settings:</p><ul><li>Add a new nameserver and choose the desired provider</li><li>Hit the <code>...</code> on the menu item <strong>-></strong> Edit</li><li>Enable &ldquo;Restrict to domain&rdquo;</li><li>Set the private domain you have ownership to as the restricted domain</li></ul><p>Changes propagate quite fast with Tailscale to the mobile app, so
you should be able to connect to cellular network and try it out!</p><p>If the solution does not yet work, check if your newly added A records
in your domain registrar&rsquo;s system have been added to the public resolvers
you configured earlier:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>dig whatever.foobar.com @1.1.1.1  <span class=c1># using the public resolver you added in the previous steps </span>
</span></span></code></pre></div><h3 id=other-services>Other services<a hidden class=anchor aria-hidden=true href=#other-services>#</a></h3><p>At this point, a working home lab on-the-go should be up and running! All the services
running on your host with domain names should work when you have TLS certificates in place,
A records configured to point to your home server,
and the reverse proxies for the services running on the host(s).</p><p>These could be anything you do labbing with such as:</p><ul><li>Home Assistant - bring your home automation with you.</li><li>RSS Reader - read news with the reader you use at home (Miniflux is pretty nice and simple).</li><li>Photo gallery - Photoprism is a cool project!</li><li>NFS - Personal data store in the pocket.</li></ul><h2 id=summary>Summary<a hidden class=anchor aria-hidden=true href=#summary>#</a></h2><p>In this post, a setup with Tailscale VPN and home lab connectivity was explored. Tailscale
provides a way to automatically turn on VPN when leaving the house, so you&rsquo;ll always
have your lab services with you. Tailscale provides handful of native integrations
for web servers and NFS, but these were not discussed this time.</p><p>Alternative options to implement this could include using <code>.lan</code> or similar
convention for local addresses and Tailnet machine names and addresses separately. This way,
no domain registrar would be needed. In this case however, if TLS is a needed feature,
a separate CA needs to be created and added to each Tailnet device&rsquo;s trust store
to avoid nagging about self-signed certificates.</p><p>Also, many Tailscale features like programmatic APIs, sharing services with friends,
more granular ACL controls, and such were not explored this time. Also, setting up
the LE certificates with auto renewal e.g. for Caddy or Nginx is a separate adventure of its own.</p><p>What are you running at home that you like to have also with you on-the-go?</p><h2 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h2><ul><li><a href=https://tailscale.com/why-tailscale>Tailscale - Why Tailscale?</a></li><li><a href=https://tailscale.com/kb/1123/zero-trust>Tailscale Docs - Zero Trust</a></li><li><a href=https://tailscale.com/compare/wireguard>Tailscale Docs - Wireguard Comparison</a></li><li><a href=https://eff-certbot.readthedocs.io/en/stable/>Certbot Docs</a></li><li><a href=https://en.wikipedia.org/wiki/WireGuard>Wireguard - Wikipedia</a></li><li><a href=https://tailscale.com/kb/1304/ip-pool>Tailscale - IP Address Pool</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://kraashen.github.io/tags/network/>Network</a></li><li><a href=https://kraashen.github.io/tags/tailscale/>Tailscale</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://kraashen.github.io/>tracing bytes</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>