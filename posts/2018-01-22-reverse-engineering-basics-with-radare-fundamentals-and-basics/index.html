<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Reverse Engineering With Radare - Fundamentals and Basics | tracing bytes</title>
<meta name=keywords content="reverse engineering,radare,studying"><meta name=description content="As I got more and more curious on how software works, I felt it essential as a software and systems engineer to start understanding deeper low-level internals of software. So I thought about diving more into the topic of reverse engineering from software developer&rsquo;s perspective using an open source tool called Radare. There are plenty of extremely well written Radare tutorials on reverse engineering which may include topics such as finding hidden passwords and injection techniques."><meta name=author content><link rel=canonical href=https://kraashen.github.io/posts/2018-01-22-reverse-engineering-basics-with-radare-fundamentals-and-basics/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://kraashen.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://kraashen.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://kraashen.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://kraashen.github.io/apple-touch-icon.png><link rel=mask-icon href=https://kraashen.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://kraashen.github.io/posts/2018-01-22-reverse-engineering-basics-with-radare-fundamentals-and-basics/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Reverse Engineering With Radare - Fundamentals and Basics"><meta property="og:description" content="As I got more and more curious on how software works, I felt it essential as a software and systems engineer to start understanding deeper low-level internals of software. So I thought about diving more into the topic of reverse engineering from software developer&rsquo;s perspective using an open source tool called Radare. There are plenty of extremely well written Radare tutorials on reverse engineering which may include topics such as finding hidden passwords and injection techniques."><meta property="og:type" content="article"><meta property="og:url" content="https://kraashen.github.io/posts/2018-01-22-reverse-engineering-basics-with-radare-fundamentals-and-basics/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-01-22T00:00:00+00:00"><meta property="article:modified_time" content="2018-01-22T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Reverse Engineering With Radare - Fundamentals and Basics"><meta name=twitter:description content="As I got more and more curious on how software works, I felt it essential as a software and systems engineer to start understanding deeper low-level internals of software. So I thought about diving more into the topic of reverse engineering from software developer&rsquo;s perspective using an open source tool called Radare. There are plenty of extremely well written Radare tutorials on reverse engineering which may include topics such as finding hidden passwords and injection techniques."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://kraashen.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Reverse Engineering With Radare - Fundamentals and Basics","item":"https://kraashen.github.io/posts/2018-01-22-reverse-engineering-basics-with-radare-fundamentals-and-basics/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Reverse Engineering With Radare - Fundamentals and Basics","name":"Reverse Engineering With Radare - Fundamentals and Basics","description":"As I got more and more curious on how software works, I felt it essential as a software and systems engineer to start understanding deeper low-level internals of software. So I thought about diving more into the topic of reverse engineering from software developer\u0026rsquo;s perspective using an open source tool called Radare. There are plenty of extremely well written Radare tutorials on reverse engineering which may include topics such as finding hidden passwords and injection techniques.","keywords":["reverse engineering","radare","studying"],"articleBody":"As I got more and more curious on how software works, I felt it essential as a software and systems engineer to start understanding deeper low-level internals of software. So I thought about diving more into the topic of reverse engineering from software developer’s perspective using an open source tool called Radare. There are plenty of extremely well written Radare tutorials on reverse engineering which may include topics such as finding hidden passwords and injection techniques. However, I did not find so many articles on how to analyze binaries in general and at the same time understand it together with the knowledge of computer architectures and their murky innards.\nSo eventually, reality hit me: It’s been almost 10 years from my computer architecture classes! I had no prior experience in reverse engineering besides the recent online examples. I tried to dive into Radare in straightforward manner with some hands-on examples, but I repeatedly came to wonder how memory management works, how assembly code should be read properly, how registers are used (and what they even were), and so forth. Well, I was still successful though in reverse engineering some simple applications related to password hunting exercises, but then I decided to go back to basics.\nSo, couple of steps back, and back to studying some computer architectures. Hopefully it will help understanding low-level code and how to analyze it better.\nIn this post, I’ll go through some of the very basic things in reverse engineering and computer architectures that I had to study and revise a bit. Also, a look will be taken on how to disassemble a very simple Hello World binary using Radare. I will explain the software at the later part of this post.\nThe goal is to get familiar with understanding assembly and how software internals work. These will be combined together with some topics that I felt essential in starting a journey in reverse engineering and understanding software internals without prior knowledge of any kind of reverse engineering.\nReverse Engineering Wikipedia defines reverse engineering in general as:\n– the processes of extracting knowledge or design information from a product and reproducing it or reproducing anything based on the extracted information. The process often involves disassembling something (a mechanical device, electronic component, computer program, or biological, chemical, or organic matter) and analyzing its components and workings in detail.\nWhen it comes to software, the meaning may vary. There are taxonomies that define reverse engineering as rebuilding or understanding the system logic from the end to the beginning (or vice versa).\nHowever, there can be different types of systems to analyze: some of them can be black boxes where there is no source code available, they can be obfuscated, and some may be commented or documented or not neither at all. Reverse engineering of software may also have different kind of goals: dissecting, also known as disassemblying, the software binary in raw machine language to understand how it works and what it does (which is what Radare does, for instance), analysing the information exchange of the software e.g. in network traffic when it comes to protocol reverse engineering, and decompiling the software, which is a technique to attempt to create a high-level representation of the original binary and it’s contents.\nIn this post, focus will be on reverse engineering software binaries.\nAssembly, Assembling, and Disassembling Assembly (ASM, aka. Assembler) language is a low-level programming language. It is very close to the machine code instructions of the hardware, and is dependent to the architectures it has been developed for. Assembly uses mnemonics - short textual and easily rememberable statements - that represent low-level machine instructions (code) which are referred to as opcodes, registers, and flags. Assembly is converted to machine code using an assembler. There are also multiple types of assemblers, which allow e.g. cross-compilation of existing ASM code to other systems.\nLets take a look at a simple “Hello World w/ assembly” program:\n#include int main(void) { printf(\"Hello World w/ Assembly!\\n\"); return 0; } I use Windows Subsystem for Linux, which allows me to run Linux binaries on Windows. This code compiles with GCC on Windows platform with WSL into following bytecode\n$ hexdump -C | head 00000000 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 |.ELF............| 00000010 02 00 3e 00 01 00 00 00 30 04 40 00 00 00 00 00 |..\u003e.....0.@.....| 00000020 40 00 00 00 00 00 00 00 d8 19 00 00 00 00 00 00 |@...............| 00000030 00 00 00 00 40 00 38 00 09 00 40 00 1f 00 1c 00 |....@.8...@.....| 00000040 06 00 00 00 05 00 00 00 40 00 00 00 00 00 00 00 |........@.......| 00000050 40 00 40 00 00 00 00 00 40 00 40 00 00 00 00 00 |@.@.....@.@.....| 00000060 f8 01 00 00 00 00 00 00 f8 01 00 00 00 00 00 00 |................| 00000070 08 00 00 00 00 00 00 00 03 00 00 00 04 00 00 00 |................| 00000080 38 02 00 00 00 00 00 00 38 02 40 00 00 00 00 00 |8.......8.@.....| 00000090 38 02 40 00 00 00 00 00 1c 00 00 00 00 00 00 00 |8.@.............| ... Which shown in disassembled form in Radare as\n\u003e s main \u003e pdf | 0x00400526 55 push rbp | 0x00400527 4889e5 mov rbp, rsp | 0x0040052a bfc4054000 mov edi, str.HelloWorld | 0x0040052f e8ccfeffff call sym.imp.puts | sym.imp.puts(unk) | 0x00400534 b800000000 mov eax, 0x0 | 0x00400539 5d pop rbp \\ 0x0040053a c3 ret Binaries A binary file is essentially a sequence of bytes. There are different types of binary files, which may include e.g. images and audio files. However, a software binary can be defined as:\nA file is interpreted as a representation of a software in machine code when it is a not a text file (binary) and is treated as an executable and ran by the system.\nBinaries may include information such as headers and other metadata which the system uses how to interpret the file when executed. Binaries without headers and metadata is called a flat binary. Exploring hex dumps of the machine code to understand the internals of it may be tedious, so this is where disassemblying comes to play.\nDisassemblers Disassembler is a program that translates the compiled machine code representation to assembly language. The output of the program aims for readability, making it eventually a reverse-engineering tool. While disassembler produces an assembly output of the original software, an interactive disassembler allows examination of the software that shows the changes made by the user. Originally IDA software actually was for easily foxing software errors and mistakes interactively. Software such as Radare in this case work greatly as a debugger as well, so it is also possible to interact and examine the software while running and debugging it.\nOpcodes and instructions Opcode stands for operation code. All opcodes together form the instruction set of the processor. An instruction set is a specified set of commands a processor can execute. Opcodes are a part of these machine language which tell the processor what operation is to be performed. Opcodes also may include operands that act as the data to be processed by the operation. They can be represented in a short textual form called instructions that are mnemonics which tell the programmer what operation is being performed in an easily memorable and understandable form.\nPUSH ebp ; \u003c- Here, PUSH is an instruction and ebp is the operand MOV ebp, esp ; \u003c- Same rules apply ... SUB ebp, 0x04h ; and so forth Opcodes and instruction sets are different depending across various processor architectures, and some architectures support different types of instructions. Operands may be e.g. memory addresses and values in the stack. To understand the instructions supported by your architecture or the architecture of the software you are reverse engineering, you’ll have to look for reference manuals of that specific architecture.\nRegisters There are many register types, especially when it comes to hardware registers. In assembly language and reverse engineering, we’ll be talking mostly about processor registers. These are the real deal in this case.\nThe operations described earlier process data. This data is stored in memory. It can be volatile memory (RAM) or non-volatile memory (disk). Most of the time, CPU instructions handle data in RAM or in the registers. In some special cases it can also be done on disk using real-mode BIOS interrupts. The data is faster to handle in the processor itself instead of doing operations in the memory. Processors have a set of registers that act as a temporary and quickly available location for data to be processed.\nregisters vary between different architectures as well. Here, focus will be on Intel x86 architecture to take a brief look on some basics. Registers are categorized according to the instructions that operate on them.\nGeneral-purpose registers As the name implies, general-purpose registers (GPR) can hold data or a memory location in a form of address. They can be used quite freely by the programmer with opcodes without too much limitations. GPRs have conventions based on their naming, but modern CPUs can use them flexibly for storing data, and different environments have different conventions. Even compilers exploit this freedom of conventions on different platforms.\nx86 architecture GPRs are:\nAX (Accumulator register). CX (Counter register). DX (Data Register). BX (Base register). SP (Stack Pointer register). BP (Stack Base Pointer register). SI (Source Index register). DI (Destination Index register). These listed are all by default 16-bit registers. Registers are categorized to 8, 16, 32, and 64 -bit register based on their prefixes and suffixes:\nE appended to the register abbreviation (E = extended), means a 32-bit register. EAX, ECX… R appended, means a 64-bit register. RAX, RCX… Accumulator, counter, data, and base registers with either H or L suffix mean 8-bit register. H as suffix means the most-significant byte, higher half of the 16 bits. L as suffix means the least-significant byte, lower half of the 16 bits. Let’s take a look at a table to get a better look:\nRegister bits AX CX DX BX 64-bit RAX RCX RDX RBX 32-bit EAX ECX EDX EBX 16-bit AX CX DX BX 8-bit AH/AL CH/CL DH/DL BH/BL Similarly this works for stack pointer, base pointer, source index, and destination index registers, but they don’t have 8-bit correspondents.\nFlags In processors, there is a long list of so called flags that exist within the 32-bit register. What are they for?\nThe results of certain operations or state are stored to these flags with either bit value set to 0 or 1. From this flag register, the processor will understand what operation will be executed next and how. For instance, opcode JNE (jump to memory location if operands are not equal) uses flag ZF, which is a flag to indicate whether result of an operation is zero. Similarly, when doing calculation with large integers, which can overflow, an overflow flag OF is used to indicate if the result is too large for the register to contain.\nFlags themselves are rarely visible from the assembly itself, but it is useful to understand how they work.\nHeap \u0026 Stack - high level look Still hanging along? Great! Before going into actual reverse engineering example, a quick look will be taken at how heap and stack memory works in assembly. This is essential to help understanding what is happening in the assembly code and why. I won’t dive into too much details here, so I recommend also checking out more detailed sources on memory management as well in the end of this post.\nWhen a software is executed, memory is reserved for the application. Part of this memory is allocated for stack and the maximum size of it is usually fixed by the operating system. Part of the memory is reserved for heap.\nHow does the stack memory work? It is fairly simple. It’s pretty much similar to the stack data type, where values are pushed on top of the stack and popped out in the reverse order to be used. Like a LIFO queue. It’s like blazing-fast bookkeeping and putting stuff aside while doing something else.\nStack size is fixed from the start of the application or thread. If there are multiple threads, they will have their own memory stack. When the stack is reserved, the stack pointer ESP (32-bit system) will point to the top of the stack. The stack grows downwards from the top to the bottom and stack pointer address follows on the top of the stack. If the pointer runs out of memory address scope and therefore past the top, a stack buffer overflow will occur.\nStack contains e.g.:\nLocal variables of functions that will go out of scope after executing them. Return address of the function, i.e. where will the processor continue after the function returns Function arguments before calling them NOTE! There are also conventions to use registers for function arguments instead of the stack. For instance, 64-bit Windows systems do this, which I learned the hard way. How about heap? In contrast to stack, heap is more flexible and more unorganized. It is separate memory from the stack without a specific layout. A programmer can define and manipulate variables which are placed on heap. Programmer will then have the responsibility of releasing this memory manually. In some languages, this is done by garbage collector when the variables are not used anymore.\nWhile stack memory is fixed, memory on the heap is allocated and deallocated dynamically during the run-time of an application. When a software runs out of heap memory, a heap overflow will occur. Without memory protection on the systems, even data outside the scope of the software could be affected.\nFollowing picture shows an example of a layout of a stack and heap within the memory allocated to an application. (Source)\nSo, some key differences:\nStack Managed by compiler (mostly, of course programmer has the power which are local variables in functions) Last-in-first-out (LIFO) -principle Contains local variables, return addresses of functions Grows from the top to bottom Fixed in size (usually) Variables are deallocated automatically when they go out of scope Threads have own stacks Heap Managed by programmer Contains variables that are out of local scope Programmer or garbage collector is responsible in freeing the memory Grows from the bottom to the top Allocated in run-time More heap can be allocated by the operating system if the amount of memory is not sufficient Threads share the heap Radare? Enter Radare! It is a cross-platform open source tool and swiss army knife for binary analysis. In this blog post, I’m talking mainly about Radare2 which is a rewritten project based on the original Radare project. Commonly people refer to it also just as Radare.\nRadare has a really steep learning curve for reverse engineering, at least for a newbie like me, so I’ll break down some basic commands that might be useful to get started tweaking around. I’m still studying it more myself as well, so I’ll also try to break down the analysis into understandable chunks.\nBased on Github:\nRadare project started as a forensics tool, a scriptable commandline hexadecimal editor able to open disk files, but later support for analyzing binaries, disassembling code, debugging programs, attaching to remote gdb servers, ..\nThe user interface is Vim-like by default, but nowadays there are also GUIs available to get more IDA-kind of feeling and which have been quite active recently.\nHere are some of the features of Radare and what is can do at the time of writing:\nDisassemblying and assemblying Debugging Hex editing Injection Emulator Binary diffing Hello World revisited So having just installed and fired up Radare with the compiled binary and you land on an empty terminal. What now? It works like a shell. In fact - it is a shell.\nIf you type ? after a command and hit return, you’ll get help texts related to that command or subcommand. ie lists the entrypoints of the binary. Handy for pinpointing where the application logic starts. iz lists strings of the binary. iI tells information about the binary, related to the headers that were discussed briefly in the binary section V toggles visual mode VV toggles visual mode with graph p is used for navigating between different views in the visual mode. Use hjkl to navigate around. s short for “seek”. Takes a variable, address or function name as an argument to seek within the address space of the application. ~ is used for grepping something from the output of previous command. Think: iz~Hello p print command pdf print disassembled function aa(a), this is your trusted companion to start analyzing. aa stands for analyze all, but does not really do all it could do (huh?). The newer aaa does a bit more extensive analysis You can also start Radare using r2 -A[A] command line flags to do initial analysis. So what has a simple Hello World eaten? Let’s check out the file information:\n\u003e iI file [snip] type EXEC (Executable file) pic false has_va true root elf class ELF64 lang c arch x86 bits 64 machine AMD x86-64 architecture os linux subsys linux endian little ... So here we can see plenty of information: The file is a Linux (ELF) executable developed in C (duh?) on x86 64-bit architecture, and it’s little endian. Now let’s analyze the binary and check out its internals:\n; what 'aa' does \u003e aa [x] Analyze all flags starting with sym. and entry0 (aa) ; what 'aaa' does \u003e aaa [x] Analyze all flags starting with sym. and entry0 (aa) [x] Analyze len bytes of instructions for references (aar) [x] Analyze function calls (aac) [x] Use -AA or aaaa to perform additional experimental analysis. [x] Constructing a function name for fcn.* and sym.func.* functions (aan) ; 'aaaa' mentioned? we must go deeper... \u003e aaaa [x] Analyze all flags starting with sym. and entry0 (aa) [x] Analyze len bytes of instructions for references (aar) [x] Analyze function calls (aac) [x] Emulate code to find computed references (aae) [x] Analyze consecutive function (aat) [x] Constructing a function name for fcn.* and sym.func.* functions (aan) [x] Type matching analysis for all functions (afta) ; lets seek to the main function \u003e s main ; ...and check out the main function with print disassemble function command \u003e pdf / (fcn) sym.main 21 | 0x00400526 55 push rbp | 0x00400527 4889e5 mov rbp, rsp | 0x0040052a bfc4054000 mov edi, str.HelloWorldwassembly | 0x0040052f e8ccfeffff call sym.imp.puts | sym.imp.puts(unk) | 0x00400534 b800000000 mov eax, 0x0 | 0x00400539 5d pop rbp \\ 0x0040053a c3 ret Alright, great! Now we are ended up in the main function of the application. So let’s break this down and use our knowledge from earlier to see what’s going on. Layout of the pdf output is following:\nmemory address opcodes in hex instruction and operands 0x00400526 55 push rbp So lets break it down line by line what happens here:\n; the base pointer, where the execution currently is, is pushed to the stack ; the program will later know that it will return the execution here 0x00400526 55 push rbp ; move current stack pointer to the base pointer register 0x00400527 4889e5 mov rbp, rsp ; move our Hello World! string to the edi register 0x0040052a bfc4054000 mov edi, str.HelloWorldwassembly ; call the puts function to print the string from the register ; the function will pick up the parameter as an argument from the edi register 0x0040052f e8ccfeffff call sym.imp.puts sym.imp.puts(unk) ; set eax register value to zero, which is our set return value 0x00400534 b800000000 mov eax, 0x0 ; pop the value we put to the stack earlier back to the base pointer register 0x00400539 5d pop rbp ; finally, return 0x0040053a c3 ret Conclusions This was quite a journey. Here, basics of computer architectures were revisited and reverse engineering principles were studied without too much prior knowledge of them using Radare. It felt a bit silly having a Hello World example here, but I found it still useful to understand and combine system fundamentals together with the syntax and basics of assembly, how Radare is used, and it gave a basic toolset to start diving a bit more deeper from now on.\nRadare has also a nice list of other tools that come in handy for binary analysis. These include binary diffing, binary inspection, command line parameters for analyze-all during startup, debugging… But they will be topics for other posts later on.\nMegabeets: A journey into Radare2 is really good blog post to read through as a next step and I highly recommend it. That post and Disobey event in Finland both inspired me a lot to start studying the topic more. The Megabeets post goes a bit more deep into analysis of a binary and shows more features of Radare that can be used to reverse engineer binaries and explains them in a very good way.\nSources to study Wikipedia: Integer overflow Wikipedia: Computer architecture Studytonight: Architecture of computer system Wikibooks: X86 Architecture X86 Opcode and Instruction Reference Wikipedia: Memory management ","wordCount":"3541","inLanguage":"en","datePublished":"2018-01-22T00:00:00Z","dateModified":"2018-01-22T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://kraashen.github.io/posts/2018-01-22-reverse-engineering-basics-with-radare-fundamentals-and-basics/"},"publisher":{"@type":"Organization","name":"tracing bytes","logo":{"@type":"ImageObject","url":"https://kraashen.github.io/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://kraashen.github.io/ accesskey=h title="tracing bytes (Alt + H)">tracing bytes</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://kraashen.github.io/ title=Home><span>Home</span></a></li><li><a href=https://kraashen.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://kraashen.github.io/snippets/ title=Snippets><span>Snippets</span></a></li><li><a href=https://kraashen.github.io/my-library/ title="My Library"><span>My Library</span></a></li><li><a href=https://kraashen.github.io/interests/ title=Interests><span>Interests</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Reverse Engineering With Radare - Fundamentals and Basics</h1><div class=post-meta><span title='2018-01-22 00:00:00 +0000 UTC'>January 22, 2018</span></div></header><div class=post-content><p>As I got more and more curious on how software works, I felt it essential as a software and systems engineer to start understanding deeper low-level internals of software. So I thought about diving more into the topic of reverse engineering from software developer&rsquo;s perspective using an open source tool called Radare. There are plenty of extremely well written Radare tutorials on reverse engineering which may include topics such as finding hidden passwords and injection techniques. However, I did not find so many articles on how to analyze binaries in general and at the same time understand it together with the knowledge of computer architectures and their murky innards.</p><p>So eventually, reality hit me: It&rsquo;s been almost 10 years from my computer architecture classes! I had no prior experience in reverse engineering besides the recent online examples. I tried to dive into Radare in straightforward manner with some hands-on examples, but I repeatedly came to wonder how memory management works, how assembly code should be read <em>properly</em>, how registers are used (and what they even were), and so forth. Well, I was still successful though in reverse engineering some simple applications related to password hunting exercises, but then I decided to go back to basics.</p><p>So, couple of steps back, and back to studying some computer architectures. Hopefully it will help understanding low-level code and how to analyze it better.</p><p>In this post, I&rsquo;ll go through some of the very basic things in reverse engineering and computer architectures that I had to study and revise a bit. Also, a look will be taken on how to disassemble a very simple Hello World binary using <a href=https://www.radare.org/r/>Radare</a>. I will explain the software at the later part of this post.</p><p>The goal is to get familiar with understanding assembly and how software internals work. These will be combined together with some topics that I felt essential in starting a journey in reverse engineering and understanding software internals without prior knowledge of any kind of reverse engineering.</p><h1 id=reverse-engineering>Reverse Engineering<a hidden class=anchor aria-hidden=true href=#reverse-engineering>#</a></h1><p>Wikipedia defines reverse engineering in general as:</p><blockquote><p>&ndash; the processes of extracting knowledge or design information from a product and reproducing it or reproducing anything based on the extracted information. The process often involves disassembling something (a mechanical device, electronic component, computer program, or biological, chemical, or organic matter) and analyzing its components and workings in detail.</p></blockquote><p>When it comes to software, the meaning may vary. There are taxonomies that define reverse engineering as rebuilding or understanding the system logic from the end to the beginning (or vice versa).</p><p>However, there can be different types of systems to analyze: some of them can be black boxes where there is no source code available, they can be obfuscated, and some may be commented or documented or not neither at all. Reverse engineering of software may also have different kind of goals: dissecting, also known as disassemblying, the software binary in raw machine language to understand how it works and what it does (which is what Radare does, for instance), analysing the information exchange of the software e.g. in network traffic when it comes to protocol reverse engineering, and decompiling the software, which is a technique to attempt to create a high-level representation of the original binary and it&rsquo;s contents.</p><p>In this post, focus will be on reverse engineering software binaries.</p><h2 id=assembly-assembling-and-disassembling>Assembly, Assembling, and Disassembling<a hidden class=anchor aria-hidden=true href=#assembly-assembling-and-disassembling>#</a></h2><p>Assembly (ASM, aka. Assembler) language is a low-level programming language. It is very close to the machine code instructions of the hardware, and is dependent to the architectures it has been developed for. Assembly uses mnemonics - short textual and easily rememberable statements - that represent low-level machine instructions (code) which are referred to as opcodes, registers, and flags. Assembly is converted to machine code using an assembler. There are also multiple types of assemblers, which allow e.g. cross-compilation of existing ASM code to other systems.</p><p>Lets take a look at a simple &ldquo;Hello World w/ assembly&rdquo; program:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Hello World w/ Assembly!</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>I use Windows Subsystem for Linux, which allows me to run Linux binaries on Windows. This code compiles with GCC on Windows platform with WSL into following bytecode</p><pre tabindex=0><code>$ hexdump -C | head
00000000  7f 45 4c 46 02 01 01 00  00 00 00 00 00 00 00 00  |.ELF............|
00000010  02 00 3e 00 01 00 00 00  30 04 40 00 00 00 00 00  |..&gt;.....0.@.....|
00000020  40 00 00 00 00 00 00 00  d8 19 00 00 00 00 00 00  |@...............|
00000030  00 00 00 00 40 00 38 00  09 00 40 00 1f 00 1c 00  |....@.8...@.....|
00000040  06 00 00 00 05 00 00 00  40 00 00 00 00 00 00 00  |........@.......|
00000050  40 00 40 00 00 00 00 00  40 00 40 00 00 00 00 00  |@.@.....@.@.....|
00000060  f8 01 00 00 00 00 00 00  f8 01 00 00 00 00 00 00  |................|
00000070  08 00 00 00 00 00 00 00  03 00 00 00 04 00 00 00  |................|
00000080  38 02 00 00 00 00 00 00  38 02 40 00 00 00 00 00  |8.......8.@.....|
00000090  38 02 40 00 00 00 00 00  1c 00 00 00 00 00 00 00  |8.@.............|
...
</code></pre><p>Which shown in disassembled form in Radare as</p><pre tabindex=0><code class=language-assembly data-lang=assembly>&gt; s main
&gt; pdf
|           0x00400526    55           push rbp
|           0x00400527    4889e5       mov rbp, rsp
|           0x0040052a    bfc4054000   mov edi, str.HelloWorld
|           0x0040052f    e8ccfeffff   call sym.imp.puts
|              sym.imp.puts(unk)
|           0x00400534    b800000000   mov eax, 0x0
|           0x00400539    5d           pop rbp
\           0x0040053a    c3           ret
</code></pre><h4 id=binaries>Binaries<a hidden class=anchor aria-hidden=true href=#binaries>#</a></h4><p>A binary file is essentially a sequence of bytes. There are different types of binary files, which may include e.g. images and audio files. However, a software binary can be defined as:</p><blockquote><p>A file is interpreted as a representation of a software in machine code when it is a not a text file (binary) and is treated as an executable and ran by the system.</p></blockquote><p>Binaries may include information such as headers and other metadata which the system uses how to interpret the file when executed. Binaries without headers and metadata is called a flat binary. Exploring hex dumps of the machine code to understand the internals of it may be tedious, so this is where disassemblying comes to play.</p><h4 id=disassemblers>Disassemblers<a hidden class=anchor aria-hidden=true href=#disassemblers>#</a></h4><p>Disassembler is a program that translates the compiled machine code representation to assembly language. The output of the program aims for readability, making it eventually a reverse-engineering tool. While disassembler produces an assembly output of the original software, an interactive disassembler allows examination of the software that shows the changes made by the user. Originally IDA software actually was for easily foxing software errors and mistakes interactively. Software such as Radare in this case work greatly as a debugger as well, so it is also possible to interact and examine the software while running and debugging it.</p><h3 id=opcodes-and-instructions>Opcodes and instructions<a hidden class=anchor aria-hidden=true href=#opcodes-and-instructions>#</a></h3><p>Opcode stands for operation code. All opcodes together form the instruction set of the processor. An instruction set is a specified set of commands a processor can execute. Opcodes are a part of these machine language which tell the processor what operation is to be performed. Opcodes also may include operands that act as the data to be processed by the operation. They can be represented in a short textual form called instructions that are mnemonics which tell the programmer what operation is being performed in an easily memorable and understandable form.</p><pre tabindex=0><code class=language-assembly data-lang=assembly>PUSH ebp     ; &lt;- Here, PUSH is an instruction and ebp is the operand
MOV ebp, esp ; &lt;- Same rules apply

...

SUB ebp, 0x04h 

; and so forth
</code></pre><p>Opcodes and instruction sets are different depending across various processor architectures, and some architectures support different types of instructions. Operands may be e.g. memory addresses and values in the stack. To understand the instructions supported by your architecture or the architecture of the software you are reverse engineering, you&rsquo;ll have to look for reference manuals of that specific architecture.</p><h3 id=registers>Registers<a hidden class=anchor aria-hidden=true href=#registers>#</a></h3><p>There are many register types, especially when it comes to <a href=https://en.wikipedia.org/wiki/Hardware_register>hardware registers</a>. In assembly language and reverse engineering, we&rsquo;ll be talking mostly about processor registers. These are the real deal in this case.</p><p>The operations described earlier process data. This data is stored in memory. It can be volatile memory (RAM) or non-volatile memory (disk). Most of the time, CPU instructions handle data in RAM or in the registers. In some special cases it can also be done on disk using real-mode BIOS interrupts. The data is faster to handle in the processor itself instead of doing operations in the memory. Processors have a set of registers that act as a temporary and quickly available location for data to be processed.</p><p>registers vary between different architectures as well. Here, focus will be on Intel <a href=https://en.wikibooks.org/wiki/X86_Assembly/X86_Architecture>x86 architecture</a> to take a brief look on some basics. Registers are categorized according to the instructions that operate on them.</p><h4 id=general-purpose-registers>General-purpose registers<a hidden class=anchor aria-hidden=true href=#general-purpose-registers>#</a></h4><p>As the name implies, general-purpose registers (GPR) can hold data or a memory location in a form of address. They can be used quite freely by the programmer with opcodes without too much limitations. GPRs have conventions based on their naming, but modern CPUs can use them flexibly for storing data, and different environments have different conventions. Even compilers exploit this freedom of conventions on different platforms.</p><p>x86 architecture GPRs are:</p><ul><li><strong>AX</strong> (Accumulator register).</li><li><strong>CX</strong> (Counter register).</li><li><strong>DX</strong> (Data Register).</li><li><strong>BX</strong> (Base register).</li><li><strong>SP</strong> (Stack Pointer register).</li><li><strong>BP</strong> (Stack Base Pointer register).</li><li><strong>SI</strong> (Source Index register).</li><li><strong>DI</strong> (Destination Index register).</li></ul><p>These listed are all by default 16-bit registers. Registers are categorized to 8, 16, 32, and 64 -bit register based on their prefixes and suffixes:</p><ul><li><code>E</code> appended to the register abbreviation (E = extended), means a 32-bit register.</li><li><code>EAX</code>, <code>ECX</code>&mldr;</li><li><code>R</code> appended, means a 64-bit register.</li><li><code>RAX</code>, <code>RCX</code>&mldr;</li><li>Accumulator, counter, data, and base registers with either <code>H</code> or <code>L</code> suffix mean 8-bit register.</li><li><code>H</code> as suffix means the most-significant byte, higher half of the 16 bits.</li><li><code>L</code> as suffix means the least-significant byte, lower half of the 16 bits.</li></ul><p>Let&rsquo;s take a look at a table to get a better look:</p><table><thead><tr><th>Register bits</th><th>AX</th><th>CX</th><th>DX</th><th>BX</th></tr></thead><tbody><tr><td>64-bit</td><td>RAX</td><td>RCX</td><td>RDX</td><td>RBX</td></tr><tr><td>32-bit</td><td>EAX</td><td>ECX</td><td>EDX</td><td>EBX</td></tr><tr><td>16-bit</td><td>AX</td><td>CX</td><td>DX</td><td>BX</td></tr><tr><td>8-bit</td><td>AH/AL</td><td>CH/CL</td><td>DH/DL</td><td>BH/BL</td></tr></tbody></table><p>Similarly this works for stack pointer, base pointer, source index, and destination index registers, but they don&rsquo;t have 8-bit correspondents.</p><h4 id=flags>Flags<a hidden class=anchor aria-hidden=true href=#flags>#</a></h4><p>In processors, there is <a href=https://en.wikibooks.org/wiki/X86_Assembly/X86_Architecture#EFLAGS_Register>a long list of so called flags</a> that exist within the 32-bit register. What are they for?</p><p>The results of certain operations or state are stored to these flags with either bit value set to 0 or 1. From this flag register, the processor will understand what operation will be executed next and how. For instance, opcode <code>JNE</code> (jump to memory location if operands are not equal) uses flag <code>ZF</code>, which is a flag to indicate whether result of an operation is zero. Similarly, when doing calculation with large integers, which can <a href=https://en.wikipedia.org/wiki/Integer_overflow>overflow</a>, an overflow flag <code>OF</code> is used to indicate if the result is too large for the register to contain.</p><p>Flags themselves are rarely visible from the assembly itself, but it is useful to understand how they work.</p><h3 id=heap--stack---high-level-look>Heap & Stack - high level look<a hidden class=anchor aria-hidden=true href=#heap--stack---high-level-look>#</a></h3><p>Still hanging along? Great! Before going into actual reverse engineering example, a quick look will be taken at how heap and stack memory works in assembly. This is essential to help understanding what is happening in the assembly code and why. I won&rsquo;t dive into too much details here, so I recommend also checking out more detailed sources on memory management as well in the end of this post.</p><p>When a software is executed, memory is reserved for the application. Part of this memory is allocated for stack and the maximum size of it is usually fixed by the operating system. Part of the memory is reserved for heap.</p><p>How does the stack memory work? It is fairly simple. It&rsquo;s pretty much similar to the <a href=https://en.wikipedia.org/wiki/Stack_(abstract_data_type)>stack data type</a>, where values are pushed on top of the stack and popped out in the reverse order to be used. Like a LIFO queue. It&rsquo;s like blazing-fast bookkeeping and putting stuff aside while doing something else.</p><p>Stack size is fixed from the start of the application or thread. If there are multiple threads, they will have their own memory stack. When the stack is reserved, the stack pointer <code>ESP</code> (32-bit system) will point to the top of the stack. The stack grows downwards from the top to the bottom and stack pointer address follows on the top of the stack. If the pointer runs out of memory address scope and therefore past the top, a <a href=https://en.wikipedia.org/wiki/Stack_buffer_overflow>stack buffer overflow</a> will occur.</p><p>Stack contains e.g.:</p><ul><li>Local variables of functions that will go out of scope after executing them.</li><li>Return address of the function, i.e. where will the processor continue after the function returns</li><li>Function arguments before calling them</li><li>NOTE! There are also conventions to use registers for function arguments instead of the stack. For instance, 64-bit Windows systems do this, which I learned the hard way.</li></ul><p>How about heap? In contrast to stack, heap is more flexible and more unorganized. It is separate memory from the stack without a specific layout. A programmer can define and manipulate variables which are placed on heap. Programmer will then have the responsibility of releasing this memory manually. In some languages, this is done by garbage collector when the variables are not used anymore.</p><p>While stack memory is fixed, memory on the heap is allocated and deallocated dynamically during the run-time of an application. When a software runs out of heap memory, a <a href=https://en.wikipedia.org/wiki/Heap_overflow>heap overflow</a> will occur. Without memory protection on the systems, even data outside the scope of the software could be affected.</p><p>Following picture shows an example of a layout of a stack and heap within the memory allocated to an application. (<a href=https://en.wikipedia.org/wiki/Data_segment>Source</a>)</p><p><img loading=lazy src=/img/memorylayout.png alt></p><p>So, some key differences:</p><h4 id=stack>Stack<a hidden class=anchor aria-hidden=true href=#stack>#</a></h4><ul><li>Managed by compiler (mostly, of course programmer has the power which are local variables in functions)</li><li>Last-in-first-out (LIFO) -principle</li><li>Contains local variables, return addresses of functions</li><li>Grows from the top to bottom</li><li>Fixed in size (usually)</li><li>Variables are deallocated automatically when they go out of scope</li><li>Threads have own stacks</li></ul><h4 id=heap>Heap<a hidden class=anchor aria-hidden=true href=#heap>#</a></h4><ul><li>Managed by programmer</li><li>Contains variables that are out of local scope</li><li>Programmer or garbage collector is responsible in freeing the memory</li><li>Grows from the bottom to the top</li><li>Allocated in run-time</li><li>More heap can be allocated by the operating system if the amount of memory is not sufficient</li><li>Threads share the heap</li></ul><h1 id=radare>Radare?<a hidden class=anchor aria-hidden=true href=#radare>#</a></h1><p>Enter Radare! It is a cross-platform open source tool and swiss army knife for binary analysis. In this blog post, I&rsquo;m talking mainly about Radare2 which is a rewritten project based on the original Radare project. Commonly people refer to it also just as Radare.</p><p>Radare has a <strong>really</strong> steep learning curve for reverse engineering, at least for a newbie like me, so I&rsquo;ll break down some basic commands that might be useful to get started tweaking around. I&rsquo;m still studying it more myself as well, so I&rsquo;ll also try to break down the analysis into understandable chunks.</p><p>Based on Github:</p><blockquote><p>Radare project started as a forensics tool, a scriptable commandline hexadecimal editor able to open disk files, but later support for analyzing binaries, disassembling code, debugging programs, attaching to remote gdb servers, ..</p></blockquote><p>The user interface is Vim-like by default, but nowadays there are also GUIs available to get more IDA-kind of feeling and which have been quite active recently.</p><p>Here are some of the features of Radare and what is can do at the time of writing:</p><ul><li>Disassemblying and assemblying</li><li>Debugging</li><li>Hex editing</li><li>Injection</li><li>Emulator</li><li>Binary diffing</li></ul><h2 id=hello-world-revisited>Hello World revisited<a hidden class=anchor aria-hidden=true href=#hello-world-revisited>#</a></h2><p>So having just installed and fired up Radare with the compiled binary and you land on an empty terminal. What now? It works like a shell. In fact - it is a shell.</p><ul><li>If you type <code>?</code> after a command and hit return, you&rsquo;ll get help texts related to that command or subcommand.</li><li><code>ie</code> lists the entrypoints of the binary. Handy for pinpointing where the application logic starts.</li><li><code>iz</code> lists strings of the binary.</li><li><code>iI</code> tells information about the binary, related to the headers that were discussed briefly in the binary section</li><li><code>V</code> toggles visual mode</li><li><code>VV</code> toggles visual mode with graph</li><li><code>p</code> is used for navigating between different views in the visual mode. Use <code>hjkl</code> to navigate around.</li><li><code>s</code> short for &ldquo;seek&rdquo;. Takes a variable, address or function name as an argument to seek within the address space of the application.</li><li><code>~</code> is used for grepping something from the output of previous command. Think: <code>iz~Hello</code></li><li><code>p</code> print command</li><li><code>pdf</code> print disassembled function</li><li><code>aa(a)</code>, this is your trusted companion to start analyzing. <code>aa</code> stands for analyze all, but does not really do all it could do (huh?). The newer <code>aaa</code> does a bit more extensive analysis</li><li>You can also start Radare using <code>r2 -A[A]</code> command line flags to do initial analysis.</li></ul><p>So what has a simple Hello World eaten? Let&rsquo;s check out the file information:</p><pre tabindex=0><code>&gt; iI
file    [snip]
type    EXEC (Executable file)
pic     false
has_va  true
root    elf
class   ELF64
lang    c
arch    x86
bits    64
machine AMD x86-64 architecture
os      linux
subsys  linux
endian  little
...
</code></pre><p>So here we can see plenty of information: The file is a Linux (ELF) executable developed in C (duh?) on x86 64-bit architecture, and it&rsquo;s little endian. Now let&rsquo;s analyze the binary and check out its internals:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=line><span class=cl><span class=c1>; what &#39;aa&#39; does
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=err>&gt;</span> <span class=nf>aa</span>
</span></span><span class=line><span class=cl><span class=err>[</span><span class=nf>x</span><span class=p>]</span> <span class=no>Analyze</span> <span class=no>all</span> <span class=no>flags</span> <span class=no>starting</span> <span class=no>with</span> <span class=no>sym.</span> <span class=no>and</span> <span class=no>entry0</span> <span class=p>(</span><span class=no>aa</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>; what &#39;aaa&#39; does
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=err>&gt;</span> <span class=nf>aaa</span>
</span></span><span class=line><span class=cl><span class=err>[</span><span class=nf>x</span><span class=p>]</span> <span class=no>Analyze</span> <span class=no>all</span> <span class=no>flags</span> <span class=no>starting</span> <span class=no>with</span> <span class=no>sym.</span> <span class=no>and</span> <span class=no>entry0</span> <span class=p>(</span><span class=no>aa</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=err>[</span><span class=nf>x</span><span class=p>]</span> <span class=no>Analyze</span> <span class=no>len</span> <span class=no>bytes</span> <span class=no>of</span> <span class=no>instructions</span> <span class=no>for</span> <span class=no>references</span> <span class=p>(</span><span class=no>aar</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=err>[</span><span class=nf>x</span><span class=p>]</span> <span class=no>Analyze</span> <span class=no>function</span> <span class=no>calls</span> <span class=p>(</span><span class=no>aac</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=err>[</span><span class=nf>x</span><span class=p>]</span> <span class=no>Use</span> <span class=p>-</span><span class=no>AA</span> <span class=no>or</span> <span class=no>aaaa</span> <span class=no>to</span> <span class=no>perform</span> <span class=no>additional</span> <span class=no>experimental</span> <span class=no>analysis.</span>
</span></span><span class=line><span class=cl><span class=err>[</span><span class=nf>x</span><span class=p>]</span> <span class=no>Constructing</span> <span class=no>a</span> <span class=no>function</span> <span class=no>name</span> <span class=no>for</span> <span class=no>fcn.</span><span class=p>*</span> <span class=no>and</span> <span class=no>sym.func.</span><span class=p>*</span> <span class=no>functions</span> <span class=p>(</span><span class=no>aan</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>; &#39;aaaa&#39; mentioned? we must go deeper...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=err>&gt;</span> <span class=nf>aaaa</span>
</span></span><span class=line><span class=cl><span class=err>[</span><span class=nf>x</span><span class=p>]</span> <span class=no>Analyze</span> <span class=no>all</span> <span class=no>flags</span> <span class=no>starting</span> <span class=no>with</span> <span class=no>sym.</span> <span class=no>and</span> <span class=no>entry0</span> <span class=p>(</span><span class=no>aa</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=err>[</span><span class=nf>x</span><span class=p>]</span> <span class=no>Analyze</span> <span class=no>len</span> <span class=no>bytes</span> <span class=no>of</span> <span class=no>instructions</span> <span class=no>for</span> <span class=no>references</span> <span class=p>(</span><span class=no>aar</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=err>[</span><span class=nf>x</span><span class=p>]</span> <span class=no>Analyze</span> <span class=no>function</span> <span class=no>calls</span> <span class=p>(</span><span class=no>aac</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=err>[</span><span class=nf>x</span><span class=p>]</span> <span class=no>Emulate</span> <span class=no>code</span> <span class=no>to</span> <span class=no>find</span> <span class=no>computed</span> <span class=no>references</span> <span class=p>(</span><span class=no>aae</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=err>[</span><span class=nf>x</span><span class=p>]</span> <span class=no>Analyze</span> <span class=no>consecutive</span> <span class=no>function</span> <span class=p>(</span><span class=no>aat</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=err>[</span><span class=nf>x</span><span class=p>]</span> <span class=no>Constructing</span> <span class=no>a</span> <span class=no>function</span> <span class=no>name</span> <span class=no>for</span> <span class=no>fcn.</span><span class=p>*</span> <span class=no>and</span> <span class=no>sym.func.</span><span class=p>*</span> <span class=no>functions</span> <span class=p>(</span><span class=no>aan</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=err>[</span><span class=nf>x</span><span class=p>]</span> <span class=no>Type</span> <span class=no>matching</span> <span class=no>analysis</span> <span class=no>for</span> <span class=no>all</span> <span class=no>functions</span> <span class=p>(</span><span class=no>afta</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>; lets seek to the main function
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=err>&gt;</span> <span class=nf>s</span> <span class=no>main</span> 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>; ...and check out the main function with print disassemble function command
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=err>&gt;</span> <span class=nf>pdf</span>
</span></span><span class=line><span class=cl><span class=err>/</span> <span class=err>(</span><span class=nf>fcn</span><span class=p>)</span> <span class=no>sym.main</span> <span class=mi>21</span>
</span></span><span class=line><span class=cl><span class=err>|</span>           <span class=err>0</span><span class=nf>x00400526</span>    <span class=mi>55</span>           <span class=no>push</span> <span class=no>rbp</span>
</span></span><span class=line><span class=cl><span class=err>|</span>           <span class=err>0</span><span class=nf>x00400527</span>    <span class=mi>4889</span><span class=no>e5</span>       <span class=no>mov</span> <span class=no>rbp</span><span class=p>,</span> <span class=no>rsp</span>
</span></span><span class=line><span class=cl><span class=err>|</span>           <span class=err>0</span><span class=nf>x0040052a</span>    <span class=no>bfc4054000</span>   <span class=no>mov</span> <span class=no>edi</span><span class=p>,</span> <span class=no>str.HelloWorldwassembly</span>
</span></span><span class=line><span class=cl><span class=err>|</span>           <span class=err>0</span><span class=nf>x0040052f</span>    <span class=no>e8ccfeffff</span>   <span class=no>call</span> <span class=no>sym.imp.puts</span>
</span></span><span class=line><span class=cl><span class=err>|</span>              <span class=nf>sym.imp.puts</span><span class=p>(</span><span class=no>unk</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=err>|</span>           <span class=err>0</span><span class=nf>x00400534</span>    <span class=no>b800000000</span>   <span class=no>mov</span> <span class=no>eax</span><span class=p>,</span> <span class=mi>0x0</span>
</span></span><span class=line><span class=cl><span class=err>|</span>           <span class=err>0</span><span class=nf>x00400539</span>    <span class=mi>5</span><span class=no>d</span>           <span class=no>pop</span> <span class=no>rbp</span>
</span></span><span class=line><span class=cl><span class=err>\</span>           <span class=err>0</span><span class=nf>x0040053a</span>    <span class=no>c3</span>           <span class=no>ret</span>
</span></span></code></pre></div><p>Alright, great! Now we are ended up in the main function of the application. So let&rsquo;s break this down and use our knowledge from earlier to see what&rsquo;s going on. Layout of the pdf output is following:</p><pre tabindex=0><code>memory address    opcodes in hex    instruction and operands    
0x00400526        55                push rbp
</code></pre><p>So lets break it down line by line what happens here:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=line><span class=cl><span class=c1>; the base pointer, where the execution currently is, is pushed to the stack
</span></span></span><span class=line><span class=cl><span class=c1>; the program will later know that it will return the execution here
</span></span></span><span class=line><span class=cl><span class=c1></span>           <span class=err>0</span><span class=nf>x00400526</span>    <span class=mi>55</span>           <span class=no>push</span> <span class=no>rbp</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>; move current stack pointer to the base pointer register
</span></span></span><span class=line><span class=cl><span class=c1></span>           <span class=err>0</span><span class=nf>x00400527</span>    <span class=mi>4889</span><span class=no>e5</span>       <span class=no>mov</span> <span class=no>rbp</span><span class=p>,</span> <span class=no>rsp</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>; move our Hello World! string to the edi register
</span></span></span><span class=line><span class=cl><span class=c1></span>           <span class=err>0</span><span class=nf>x0040052a</span>    <span class=no>bfc4054000</span>   <span class=no>mov</span> <span class=no>edi</span><span class=p>,</span> <span class=no>str.HelloWorldwassembly</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>; call the puts function to print the string from the register
</span></span></span><span class=line><span class=cl><span class=c1>; the function will pick up the parameter as an argument from the edi register
</span></span></span><span class=line><span class=cl><span class=c1></span>           <span class=err>0</span><span class=nf>x0040052f</span>    <span class=no>e8ccfeffff</span>   <span class=no>call</span> <span class=no>sym.imp.puts</span>
</span></span><span class=line><span class=cl>              <span class=nf>sym.imp.puts</span><span class=p>(</span><span class=no>unk</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>; set eax register value to zero, which is our set return value
</span></span></span><span class=line><span class=cl><span class=c1></span>           <span class=err>0</span><span class=nf>x00400534</span>    <span class=no>b800000000</span>   <span class=no>mov</span> <span class=no>eax</span><span class=p>,</span> <span class=mi>0x0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>; pop the value we put to the stack earlier back to the base pointer register
</span></span></span><span class=line><span class=cl><span class=c1></span>           <span class=err>0</span><span class=nf>x00400539</span>    <span class=mi>5</span><span class=no>d</span>           <span class=no>pop</span> <span class=no>rbp</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>; finally, return
</span></span></span><span class=line><span class=cl><span class=c1></span>           <span class=err>0</span><span class=nf>x0040053a</span>    <span class=no>c3</span>           <span class=no>ret</span>
</span></span></code></pre></div><h1 id=conclusions>Conclusions<a hidden class=anchor aria-hidden=true href=#conclusions>#</a></h1><p>This was quite a journey. Here, basics of computer architectures were revisited and reverse engineering principles were studied without too much prior knowledge of them using Radare. It felt a bit silly having a Hello World example here, but I found it still useful to understand and combine system fundamentals together with the syntax and basics of assembly, how Radare is used, and it gave a basic toolset to start diving a bit more deeper from now on.</p><p>Radare has also a nice list of other tools that come in handy for binary analysis. These include binary diffing, binary inspection, command line parameters for analyze-all during startup, debugging&mldr; But they will be topics for other posts later on.</p><p><a href=https://www.megabeets.net/a-journey-into-radare-2-part-1/>Megabeets: A journey into Radare2</a> is really good blog post to read through as a next step and I highly recommend it. That post and Disobey event in Finland both inspired me a lot to start studying the topic more. The Megabeets post goes a bit more deep into analysis of a binary and shows more features of Radare that can be used to reverse engineer binaries and explains them in a very good way.</p><h1 id=sources-to-study>Sources to study<a hidden class=anchor aria-hidden=true href=#sources-to-study>#</a></h1><ul><li><a href=https://en.wikipedia.org/wiki/Integer_overflow>Wikipedia: Integer overflow</a></li><li><a href=https://en.wikipedia.org/wiki/Computer_architecture>Wikipedia: Computer architecture</a></li><li><a href=https://www.studytonight.com/computer-architecture/architecture-of-computer-system.php>Studytonight: Architecture of computer system</a></li><li><a href=https://en.wikibooks.org/wiki/X86_Assembly/X86_Architecture#EFLAGS_Register>Wikibooks: X86 Architecture</a></li><li><a href=http://ref.x86asm.net/>X86 Opcode and Instruction Reference</a></li><li><a href=https://en.wikipedia.org/wiki/Memory_management>Wikipedia: Memory management</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://kraashen.github.io/tags/reverse-engineering/>Reverse Engineering</a></li><li><a href=https://kraashen.github.io/tags/radare/>Radare</a></li><li><a href=https://kraashen.github.io/tags/studying/>Studying</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://kraashen.github.io/>tracing bytes</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>